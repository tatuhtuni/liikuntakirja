#+PROPERTY:header-args :mkdirp yes :exports code :noweb no-export
#+OPTIONS: broken-links:t


* Developer's prologue
** Install prerequisites and nix

#+begin_src
  sudo dnf install git curl make direnv
#+end_src

#+begin_src shell :results silent :dir .
  curl -L https://nixos.org/nix/install | sh
#+end_src

Shell environment has to be reloaded now. Restart Emacs and the shell session it's running in.

** Setup notebook environment

#+begin_src elisp
  (add-to-list 'load-path "nonmanaged/org-transclusion/")
  (load "org-transclusion.el")

  (define-key global-map (kbd "<f12>") #'org-transclusion-add)
  (define-key global-map (kbd "C-c C-n t") #'org-transclusion-mode)
#+end_src

The following can be executed for a temporary session environment for this notebook. The contents are largely converted from my own =init.el=, from using =customize=-interface to using =setq=.

#+begin_src elisp
  ;; First, we wrap the whole init file in a block that sets file-name-handler-alist to nil to prevent any special-filename parsing of files loaded from the init file (e.g. remote files loaded through tramp, etc.).
  ;; Then we set gc-cons-threshold to its maximum value, to prevent any garbage collection from happening during load time.
  (let ((file-name-handler-alist nil))
    (setq gc-cons-threshold most-positive-fixnum)

  ;; Asynchronous native compilation
  (when (fboundp 'native-compile-async)
    (setq comp-deferred-compilation t
          comp-deferred-compilation-black-list '("/mu4e.*\\.el$")))

  ;; Don't confirm killing processes on exit
  (setq confirm-kill-processes nil)

  ;; Set UTF-8 as default encoding
  (set-language-environment "UTF-8")
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)

  ;; Ctrl-K at start of line also removes newline
  (setq kill-whole-line t)

  ;; No hard tabs, set indentations for major langs
  (setq indent-tabs-mode nil)
  (setq tab-width 4)
  (setq js-indent-level 2)
  (setq css-indent-level 2)

  ;; Highlight parentheses
  (setq show-paren-delay 0)
  (show-paren-mode)

  ;; Initialize package system. Add MELPA.
  (setq package-archives
        '(("melpa"     . "https://melpa.org/packages/")
          ("elpa"      . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))

  ;; By default, always try to install missing packages, always defer loading until actually needed, disable verbose loading (enable for debugging).
  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t)
  (setq use-package-verbose nil)

  ;; Org-mode
  (use-package org
    :load-path ("lisp/org-mode/lisp" "lisp/org-mode/lisp/contrib/lisp")
    :bind
    (:map org-mode-map
     ("C-c l" . org-store-link))
    :custom
    (org-directory "~/Documents/org.d")
    (org-log-done t)
    (org-startup-indented t)
    (org-log-into-drawer t)
    (org-src-fontify-natively t)
    (org-return-follows-link t)
    (org-special-ctrl-a/e t)
    (org-special-ctrl-k t)
    (org-use-speed-commands
     (lambda ()
       (and (looking-at org-outline-regexp)
            (looking-back "^\**"))))
    :custom-face

    :hook
    (org-babel-after-execute . org-redisplay-inline-images)
    :config
    )

  ;; nix-mode for syntax highlighting nix configuration files
  (use-package nix-mode
    :ensure t)
  ;; Haskell language & direnv support
  (use-package haskell-mode
    :ensure t)
  (use-package envrc
    :config
    (envrc-global-mode +1))
  (use-package eglot
    :config
    (add-hook 'haskell-mode-hook #'eglot-ensure)
    ;; Optionally add keybindings to some common functions:
    :bind ((:map eglot-mode-map
                 ("C-c C-e r" . eglot-rename)
                 ("C-c C-e l" . flymake-show-buffer-diagnostics)
                 ("C-c C-e p" . flymake-show-project-diagnostics)
                 ("C-c C-e C" . eglot-show-workspace-configuration)
                 ("C-c C-e R" . eglot-reconnect)
                 ("C-c C-e S" . eglot-shutdown)
                 ("C-c C-e A" . eglot-shutdown-all)
                 ("C-c C-e a" . eglot-code-actions)
                 ("C-c C-e f" . eglot-format))))

  ;; Allow in-place language execution for Latex, Python, Haskell, and shell languages.
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'org-babel-tangle
                            :append :local)))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell   . t)
     (haskell . t)
     (emacs-lisp   . t)))
  (setq haskell-process-type 'ghci)

  (use-package org-indent
    :ensure nil
    :diminish)

  ;; Hide emphasis markers
  (setq org-hide-emphasis-markers t)

  ;; Font-lock substitution for list markers
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; org-bullets
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  ;; Save place of cursor on exit
  (use-package saveplace
    :defer nil
    :config
    (save-place-mode))

  ;; Mode-specific bookmarks
  ;; `M-i` to jump in eg. org-mode to select heading in a list of headings.
  (use-package imenu-anywhere
    :bind
    ("M-i" . helm-imenu-anywhere))

  ;; Smooth scrolling
  ;(use-package smooth-scrolling
  ;  :ensure t
  ;  :config
  ;  (smooth-scrolling-mode 1))

  ;; Enable pixel scrolling to avoid jumping blocks when scrolling
  ;(pixel-scroll-precision-mode)
  ;(setq pixel-scroll-precision-large-scroll-height 40.0)

  ;; Delete trailing whitespace on exit
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  ;; Save on unfocus
  (defun save-all ()
    (interactive)
    (save-some-buffers t))
  (add-hook 'focus-out-hook 'save-all)

  ;; IDO for flex matching filenames and probably something else too
  (use-package ido
    :ensure t)
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode 1)

  ;; IDO-based M-x, bases guesses on current active mode
  (use-package smex
    :ensure t)
  (smex-initialize)
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)

  ;; `which-key`
  (use-package which-key
    :defer nil
    :diminish which-key-mode
    :config
    (which-key-mode))

  ;; toolbar mode off
  (tool-bar-mode -1)

  ;; Use `bind-key` instead of `global-set-key` to allow `M-x describe-personal-keybindings`.
  (require 'bind-key)

  ;; Go to line
  (bind-key "M-g" 'goto-line)

  ;; When using IDO (I think it's IDO), spaces try to auto-complete, making spaces in node names impossible. =Override IDO space matching to allow spaces in node names.=
  (define-key minibuffer-local-completion-map (kbd "SPC") 'self-insert-command)

  ;; miscellaneous
  (use-package poet-theme
    :ensure t)
  (load-theme 'poet t)
  ;(use-package wc-mode
  ;  :ensure t)
  ;(add-hook 'text-mode-hook
  ;          (lambda ()
  ;            (wc-mode 1)))
  ;(display-battery-mode t)
  (setq sentence-end-double-space nil)

  ;; playground
  (use-package magit
    :ensure t)
  (setq magit-define-global-key-bindings 'recommended)

  ;(use-package lsp-mode
  ;  :ensure t)

  ;; Optional: Show/pick completions on tab, sane max height:
  (setq tab-always-indent 'complete
        completions-max-height 20
        completion-auto-select 'second-tab)

  ;; Startup has finished. Revert performance optimizations.
  (setq gc-cons-threshold (* 2 1000 1000))
  )
#+end_src

Here are some further beautification and autosaves using the customize-interface and will mess with your own customizations permanently if any. We'll first also create an autosaves folder.
#+begin_src shell :results silent
  mkdir ~/.emacs.d/autosaves
#+end_src

#+begin_src elisp
  ;; Autosave and backup directories
  (custom-set-variables
   '(auto-save-file-name-transforms
     '((".*" "~/.emacs.d/autosaves/\\1" t)))
   '(backup-directory-alist
     '((".*" . "~/.emacs.d/backups/"))))

  ;; Headline fonts
  (when window-system
    (let* ((variable-tuple
	      (cond ((x-list-fonts "IBM Plex Serif")  '(:font "IBM Plex Serif"))
		    ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
		    (nil (warn "Cannot find a Sans Serif Font.  Install IBM Plex Serif."))))
	     (base-font-color     (face-foreground 'default nil 'default))
	     (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

	(custom-theme-set-faces
	 'user
	 `(org-level-8 ((t (,@headline ,@variable-tuple))))
	 `(org-level-7 ((t (,@headline ,@variable-tuple))))
	 `(org-level-6 ((t (,@headline ,@variable-tuple))))
	 `(org-level-5 ((t (,@headline ,@variable-tuple))))
	 `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
	 `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
	 `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
	 `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
	 `(org-document-title ((t (,@headline ,@variable-tuple :height 2.0 :underline nil))))))
    )

  ;; Variable pitch fonts, mode hook, visual line mode, custom fixed pitch faces
  (custom-theme-set-faces
    'user
    '(variable-pitch ((t (:family "IBM Plex Serif" :height 100))))
    '(fixed-pitch ((t (:family "Fantasque Sans Mono")))))
  (add-hook 'org-mode-hook 'variable-pitch-mode)
  (add-hook 'org-mode-hook 'visual-line-mode)
  (custom-theme-set-faces
    'user
    '(org-block ((t (:inherit fixed-pitch))))
    '(org-code ((t (:inherit (shadow fixed-pitch)))))
    '(org-document-info ((t (:foreground "dark orange"))))
    '(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
    '(org-indent ((t (:inherit (org-hide fixed-pitch)))))
    '(org-link ((t (:foreground "royal blue" :underline t))))
    '(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    '(org-property-value ((t (:inherit fixed-pitch))) t)
    '(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
    '(org-table ((t (:inherit fixed-pitch :foreground "#83a598"))))
    '(org-tag ((t (:inherit (shadow fixed-pitch) :weight bold :height 0.8))))
    '(org-verbatim ((t (:inherit (shadow fixed-pitch))))))

#+end_src

To run frontend visualizations =ob-html-chrome= is recommended. A Chromium browser is required.
#+begin_src elisp
  (use-package ob-html-chrome
    :ensure t)
  (require 'ob-html-chrome)
  (setq org-babel-html-chrome-chrome-executable
    "/usr/bin/chromium-browser")
#+end_src
** Setup IHP and the initial project
[a short introduction into what IHP does and what is it's working ethos.]

#+begin_src shell :results silent :dir .
  nix-env --install ihp-new
#+end_src

IHP uses nix "flakes" which require special handling when used inside git repositories like the one this notebook is in ([[https://github.com/NixOS/nix/issues/6642][nix issue #6642]], [[https://github.com/digitallyinduced/ihp/issues/1787][ihp issue #1787]]). To work around this issue, a git repository has to be created for the IHP program. As of writing this, nix still used the old =ihp-new=, so this notebook is accompanied by the =ihp-new= @ commit 016a14d. =ihp-new= will initialize git repository with default credentials and options.

Setting an IHP project up for the first time can take a long time, is verbose, and asks if precompiled binaries can be used. Thus, it is preferable to run it in a separate terminal without =yes=. If using precompiled binaries is fine,  it can be run inside the notebook:
#+begin_src shell :results silent :dir .
  yes | ./ihp-new liikuntakirja
#+end_src

With the project set up, this document should now be tangled with  =C-c C-v t=.

The following assets are needed inside the program:
#+begin_src shell :results silent :dir .
  cp assets/chart.umd.min.js liikuntakirja/static/
#+end_src

If you're making changes into the program and want to have the GHCi session reset between block executions, the following block can be run:
#+begin_src elisp :results silent
  (add-hook 'org-babel-after-execute-hook 'semacs/ob-args-ext-session-reset)

  (defun semacs/ob-args-ext-session-reset()
    (let* ((src-block-info (org-babel-get-src-block-info 'light))
           (language (nth 0 src-block-info))
           (arguments (nth 2 src-block-info))
           (should-reset (member '(:session-reset . "yes") arguments))
           (session (cdr (assoc :session arguments)))
           (session-process
            (cond ((equal language "haskell") (format "*haskell*" session))
                  (t nil))))
      (if (and should-reset (get-process session-process))
          (kill-process session-process))))
#+end_src

A header argument =:session-reset yes= can be now used per-block, per-headline, or globally. /[broken for now]/

** Project configuration

To get =ob-haskell= to execute Haskell blocks, we have to amend the default =.ghci= file with the default =ghci= prompt (=ghci>= instead of =IHP>=).
#+transclude: [[file:.ghci]]  :src haskell

Then we'll have the =nix= boilerplate.
#+transclude: [[file:Config/nix/nixpkgs-config.nix]]  :src nix

Everything should now be set for both running the program and the untangled blocks of code in this notebook. The following block can be used to test if the environment is set up properly.
#+begin_src haskell :dir .
  :t config
#+end_src

Any code block results can be cleared per-block with =C-c C-v k= and globally using universal prefix (=C-u C-c C-v k=).

** Running the program

We will have to set the =Development= / =Production= flags and a proper host name for the global =config=. These are fine for development:
#+name: Set development or production flags
#+transclude: [[file:Config/Config.hs::option Development]] :lines 1-2 :src haskell

For deployment, options can be substituted for:
#+begin_src haskell
  option Production
  option (AppHostname "domain.tld")
#+end_src

#+begin_src shell :async yes :session *ihp* :dir . :results silent
  ./start
#+end_src

** Weaving this notebook
*** HTML
#+begin_src elisp
  (use-package htmlize
    :ensure t)
#+end_src

=C-c C-e h o=
*** LaTeX
#+begin_src elisp
  (add-to-list 'org-latex-packages-alist '("" "minted" nil))
  (setq org-latex-src-block-backend 'minted)
#+end_src

=C-c C-e l o=
* The Liikuntakirja story
#+PROPERTY:header-args :dir . :mkdirp yes :exports code :noweb no-export

Liikuntakirja is a story of a person wanting to upload, view, edit, and delete their workout sessions originally recorded on a smartwatch. The universal fitness trackers found on market are too complex to use and make compromises to cover all bases. These don't cater to tracking the user's workout sessions in a minimalistic way.

The user is happy with a unified interface. A workout session can be selected from a drop-down menu and a new one can be uploaded by browsing their computer. At the same time the data from either the newest upload or the one specially selected from the drop-down is shown.

This document will lead us from the perspective of a user using the software artefact. The user will first see the front page with all added activities indexed. They will then move on to add an activity. Then they will examine the added activity. After that the activity will be deleted as unsatisfactory.

A set of tests will be derived from the story and the code derived from those will be dispersed there on a need-to-know basis, which means all of the boilerplate that doesn't fit in can be found as an appendix. The boilerplate should only have to be edited when refactoring the code or the test suite.
** User accesses Liikuntakirja via browser
Since the user is only interested in activities, we can do everything via =ActivitiesController=. =Activity= is a data structure signifying a single workout. It is examined closer in the next chapter.
#+name: Set ActivitiesAction as front page
#+begin_src haskell
        [ startPage ActivitiesAction
#+end_src

=ActivitiesAction= will query all activities from the database:
#+name: Index Activities using IndexView
#+transclude: [[file:Web/Controller/Activities.hs::action ActivitiesAction]]  :src haskell :thingatpt paragraph

And =IndexView= will then list the activities. IHP uses JSX-like HSX syntax. It enables embedding Haskell code inside page layouts.
#+name: HTML builder for Activities index
#+transclude: [[file:Web/View/Activities/Index.hs::data IndexView]] :lines 1-4 :src haskell

To add an Activity, the user finds the 'New' button found on the headline:
#+name: Lay out the headline and new Activity button
#+transclude: [[file:Web/View/Activities/Index.hs::pathTo NewActivityAction]] :lines 1-1 :src html

#+NAME: Lay out the Activities index page
#+transclude: [[file:Web/View/Activities/Index.hs::html IndexView]] :lines 2- :src html :end "|]"

#+name: the default Activities breadcrumb
#+transclude: [[file:Web/View/Activities/Index.hs::breadcrumb =]]  :src haskell :thingatpt paragraph

#+NAME: Lay out the individual Activity for indexing
#+transclude: [[file:Web/View/Activities/Index.hs::renderActivity ::]] :lines 3- :src html :thingatpt paragraph

** User uploads smartwatch data into Liikuntakirja
The user has TCX-formatted smartwatch data files on their computer, ready for uploading
*** Uploading into database
To allow user uploads to =static/= directory, we'll have to import a configuration and some flags in =Config.hs= defined at Configure IHP
#+NAME: Import upload configuration
#+transclude: [[file:Config/Config.hs::FileStorage.Config]] :lines 1-1 :src haskell
#+NAME: Allow uploads
#+transclude: [[file:Config/Config.hs::initStaticDirStorage]] :lines 1-1 :src haskell

A simple file upload form is enough, everything in =Activity= can be derived from the uploaded TCX file.
#+NAME: Lay out Activity upload form
#+transclude: [[file:Web/View/Activities/New.hs::uploadUrl]]  :src html :thingatpt paragraph

The page for uploading the new =Activity= is kept simple. *TODO:* should be integrated into =IndexView= for unified interface as requested.
#+transclude: [[file:Web/View/Activities/New.hs::data newView]] :lines 1-4 :src haskell

#+NAME: Lay out new Activity page
#+transclude: [[file:Web/View/Activities/New.hs::instance View NewView]] :lines 3- :src html :end "|]"

#+transclude: [[file:Web/View/Activities/New.hs::breadcrumb =]]  :src haskell :thingatpt paragraph

Once the user clicks "Upload", we will pass the uploaded TCX for conversion.
*** Converting the uploaded TCX file
When the user submits the form, the file arrives at the respective =ActivitiesController= action. User will be redirected back to the front page. In between, the TCX file is converted into an intermediate =TcxActivity= and finally to =Activity= compatible with our database setup.
#+NAME: Create Activity from uploaded TCX
#+begin_src haskell
  action CreateActivityAction = do
    <<Convert uploaded TCX into TcxActivity>>
    <<Convert TcxActivity into Activity and other database records>>
    <<Congratulate upload and redirect>>
#+end_src

#+name: Congratulate upload and redirect
#+transclude: [[file:Web/Controller/Activities.hs::setSuccessMessage]]  :src haskell :thingatpt paragraph

The TCX file we've received is an XML-formatted file. In the file, Trackpoints are of most interest as it keeps track of heart rate, speed and time, but Lap and Activity have some useful metadata too. An example TCX produced by a 5-second workout:
#+NAME: TCX XML for case 1
#+transclude: [[file:test.tcx]]  :src xml

The following type structures are directly derived from this XML structure with irrelevant data pruned out. We end up with a tree structure going from Activity, to Lap, to Trackpoint. Intermediate types are prefixed by 'Tcx' to avoid collisions with IHP's database-derived types. Intermediate types are used to easen the transition between top-down tree structure idiomatic to Haskell records and bottom-up tree structures idiomatic to relational databases. Activity type for conversion:
#+NAME: TcxActivity
#+transclude: [[file:Web/Types.hs::data TcxActivity]]  :src haskell :thingatpt paragraph

And the database schema derived from it:
#+NAME: Activity schema
#+transclude: [[file:Application/Schema.sql::CREATE TABLE activities]]  :src sql :end "CREATE TABLE laps"

Activities consist of one or more laps.
#+NAME: TcxLap
#+transclude: [[file:Web/Types.hs::data TcxLap]]  :src haskell :thingatpt paragraph
#+NAME: Lap schema
#+transclude: [[file:Application/Schema.sql::CREATE TABLE laps]]  :src sql :end "CREATE TABLE trackpoints"

Laps in turn consist of tracks which are collections of trackpoints. We will assume any extra tracks can be concatenated into one single track to simplify the data model.
#+NAME: TcxTrackpoint
#+transclude: [[file:Web/Types.hs::data TcxTrackpoint]]  :src haskell :thingatpt paragraph
#+NAME: Trackpoint schema
#+transclude: [[file:Application/Schema.sql::CREATE TABLE trackpoints]]  :src sql

Along with some descriptive aliases for primitive types in the application.
#+NAME: tcx types
#+transclude: [[file:Web/Types.hs::type TotalTimeSec]]  :src haskell :thingatpt paragraph

The [[TCX XML for case 1][example TCX file]] should then parse into a structure like so.
#+name: TCX XML for case 1 converted to a record
#+begin_src haskell
  [TcxActivity
    { tcxLaps =
       [ TcxLap
         { tcxLapStart = 2024-03-19 12:28:25.47 UTC
         , tcxLapTotal = 5.0
         , tcxLapDistance = 0.0
         , tcxCals = 1
         , tcxAvgHR = 61
         , tcxMaxHR = 62
         , tcxIntensity = "Active"
         , tcxTrigger = "Manual"
         , tcxTrack =
             [ TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:25.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 62
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:26.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:27.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:28.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:29.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             ]
         }
       ]
   , tcxSport = "Other"
   , tcxActStart = 2024-03-19 12:28:24.47 UTC
   , tcxPlanType = "Workout"
   , tcxDeviceName = "Polar INW3N_V2"
   }]
#+end_src

We can now make a unit testing file for these conversions. Since the XML files are big and not trivially referenced in string form in Haskell, we'll load it from a file.
#+name: TCX unit tests
#+transclude: [[file:Test/Application/TCXSpec.hs::tcxToRecord :: Spec]]  :src haskell :thingatpt paragraph

First we'll convert the uploaded XML into the =TcxActivity= record type. TCX files can theoretically have multiple =Activities=, but they are not expected in this case. Neither is graceful exception handling required due to threaded nature of IHP and the singular purpose of the upload request, so using =fromJust= as a shortcut is fine for now.
#+name: Convert uploaded TCX into TcxActivity
#+transclude: [[file:Web/Controller/Activities.hs::let tcx :: TcxActivity]]  :src haskell :end "activity <- newRecord"

The external functions used in these conversions. Using =fromJust= is fine, since we can expect XML to be correctly formed and in malformed cases the silent =error= is not an issue. The service will keep on running in these cases. We will now make the conversion function =processTcxUpload=.
#+name: Import TCX conversion functions
#+transclude: [[file:Web/Controller/Activities.hs::import Application.TCX]]  :src haskell :thingatpt paragraph

Since there are no libraries available for directly extracting the TCX format, we'll construct a filter chain using =xml-conduit= (Text.XML and Text.XML.Cursor). There are two entry points to this TCX extractor: =processTcxFile= and =processTcxUpload=. Either approach would be fine with IHP's file uploading routine, but converting from =Text= rather than from =FilePath= inside =IO= monad is more straightforward. XML extractors like /Haskell XML Toolkit/ only work with files, so having =processTcxFile= is fulfilling idiomatic expectations, but also enables testing with larger files.
#+transclude: [[file:Application/TCX.hs::processTcxFile ::]]  :src haskell :end "getActivities ::"

Extracting the fields in this case is logically simple if repetitive and verbose. It could be cleaned up with some helper functions. =read= is used, but as before, graceful exception handling is not required here, although could be relatively easily added since the return value of =[TcxActivity]= is essentially a =Maybe= structure.
#+transclude: [[file:Application/TCX.hs::getActivities ::]]  :src haskell

Having put all this together, we can now convert a TCX file into a Haskell record structure:
#+begin_src haskell
  :l Test/Main
  hspec $ Test.Application.TCXSpec.tcxToRecord
#+end_src

#+RESULTS:
: processTcxFile
:   can convert TCX file into TcxActivity [v]
:
: Finished in 0.0013 seconds
: 1 example, 0 failures

Then we can do a type conversion similar to the one we did in when reading the XML: converting from the intermediate =TcxActivity= into the =Activity=  and others, which are then saved in the database via =createRecord= and its merged INSERT variation =createMany=. IHP will then be using =Activity=, =Lap= and =Trackpoint= in the views.
#+name: Test converting TcxActivity into database records
#+begin_src haskell
  it "adds a TCX upload successfully into database" $ withContext do
    tcx <- fromJust . head <$> processTcxFile "test.tcx"
    <<Convert TcxActivity into Activity and other database records>>
    actCount <- query @Activity |> fetchCount
    actCount `shouldBe` 1
    lapCount <- query @Lap |> fetchCount
    actCount `shouldBe` 1
    tpCount <- query @Trackpoint |> fetchCount
    tpCount `shouldBe` 5
#+end_src

#+name: Convert TcxActivity into Activity and other database records
#+begin_src haskell
  activity <- newRecord @Activity
              |> set #sport (tcxSport tcx)
              |> set #startTime (tcxActStart tcx)
              |> set #planType (tcxPlanType tcx)
              |> set #deviceName (tcxDeviceName tcx)
              |> createRecord
  laps <- createMany $ map (\lap -> newRecord @Lap
                        |> set #activityId (unpackId activity.id)
                        |> set #startTime (tcxLapStart lap)
                        |> set #totalTime (tcxLapTotal lap)
                        |> set #distance (tcxLapDistance lap)
                        |> set #calories (tcxCals lap)
                        |> set #averageHr (tcxAvgHR lap)
                        |> set #maximumHr (tcxMaxHR lap)
                        |> set #intensity (tcxIntensity lap)
                        |> set #trigger (tcxTrigger lap)
               ) (tcxLaps tcx)
  let lapIdsWithTracks = zip (map (.id) laps) (map tcxTrack $ tcxLaps tcx)
  mapM_ (\(lapId, tcks) ->
           createMany $ map (\tck -> newRecord @Trackpoint
                          |> set #lapId (unpackId lapId)
                          |> set #pointTime (tcxTpTime tck)
                          |> set #distance (tcxTpDistance tck)
                          |> set #hr (tcxTpHR tck)
                          |> set #sensor (tcxSensor tck)
                 ) tcks
        ) lapIdsWithTracks
#+end_src

These two conversions then come together and with the results saved into database with =createRecord= and =createMany= earlier, we can congratulate the user and move them into the Activities index. *TODO: we'll move the user to the uploaded activity*

** Looking at an activity
*** Plotting the activity
We'll be using an external =chart.js= library for plotting the data points. We'll amend =Web/View/Layout.hs= to include it.
#+name: Import plotting library
#+transclude: [[file:Web/View/Layout.hs::chart.umd.min.js]] :lines 1-1 :src html

+A filled line chart is the weapon of choice for the heart rate over time chart, since its integral (area) could be seen as useful (total heart beats).+ A scatter chart is used for simpler =tick= handling inside chart.js. The chart type is subject to change.
#+name: Plot heart rate
#+transclude: [[file:Web/View/Activities/Show.hs::<script data-hr]]  :src js :end "|]"

#+name: Map heart rate plot values
#+begin_src haskell
  heartRateList <- return $ map hr (concat tps)
  timeList <- return [0..length (concat tps) - 1]
#+end_src
#+name: Add heart rate plot values as parameters
#+transclude: [[file:Web/View/Activities/Show.hs::heartRateList]] :lines 1-2 :src haskell
#+name: Show plotted heart rate
#+transclude: [[file:Web/View/Activities/Show.hs::hrChart]] :lines 1-1 :src html

*TODO:* test the plot out by screenshotting a headless Chrome instance with =ob-html-chrome=. Blaze-kirjastolla saanee Web.View.Showista ulos dokumentin. Mikäli HSpec tms meiningit ei tuo siistimpää ratkaisua. =cs . responseBody= voi olla hyödyllinen =Html -> Text= tjsp. Ohjelman kontekstia ei kannata ajaa kun se on liian työlästä (ja selaimesta näkee helposti), mutta yksittäisiä elementtejä voisi testata kuitenkin muuten blankossa leiskassa. HSX substituutiot pitäisi pystyä jollain ilveellä tekemään kyllä että tässä on järkeä.

#+name: Plotting example
#+begin_src html-chrome :out plot.png
  <html>
    <head>
      <script src="/chart.umd.min.js?v=dev"></script>
      <title>Plotting test</title>
    </head>
    <body>
      <<Show plotted heart rate>>
      <script>
      var ctx = document.getElementById("hrChart").getContext('2d');
      var myChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          labels: JSON.parse("[0,1,2,3,4,5]"),
          datasets: [{
            label: 'Heart rate',
            data: JSON.parse("[80,83,85,78,80]"),
            fill: true,
            borderColor: 'rgb(75, 192, 192)',
            tension: 0.1
          }]
        },
        options: {
          scales: {
            y: {
              suggestedMin: 0,
              title: {
                display: true,
                text: 'BPM'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Seconds'
              }
            }
          }
        }
      });
    </script>
#+end_src

*** Fetching activity data and showing it
We'll first have to fetch data from the database, namely the =Activity=, =Laps=, and =Trackpoints=.
#+name: Query Activity and its children
#+transclude: [[file:Web/Controller/Activities.hs::action ShowActivityAction]]  :src haskell :thingatpt paragraph

#+name: ShowView definition
#+transclude: [[file:Web/View/Activities/Show.hs::data ShowView]]  :src haskell :thingatpt paragraph

#+NAME: Show detailed view of an activity
#+transclude: [[file:Web/View/Activities/Show.hs::hsx|]] :lines 2- :src html :end "<script"

#+transclude: [[file:Web/View/Activities/Show.hs::breadcrumb =]]  :src html :thingatpt paragraph

** Deleting an activity

User has clicked delete button and confirmed deletion. Activity and its constituents will be remove from the database.
#+name: Delete an activity
#+transclude: [[file:Web/Controller/Activities.hs::action DeleteActivityAction]]  :src haskell :thingatpt paragraph
