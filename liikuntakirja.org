#+PROPERTY:header-args :mkdirp yes :exports code :noweb no-export
#+OPTIONS: broken-links:t

* Developer's prologue
** Install prerequisites and nix
The program is run in a Nix reproducible environment to ease setup and deployment. The environment depends on Git, Curl, Make, and Direnv.
#+caption: An example shell command for Dnf package manager with Fedora repositories.
#+begin_src shell
  sudo dnf install git curl make direnv
#+end_src

#+caption: Nix install script
#+begin_src shell :results silent :dir .
  curl -L https://nixos.org/nix/install | sh
#+end_src

After running the install script, shell environment has to be reloaded. Restart Emacs and the shell session it's running in.

** Setup notebook environment
The following can be executed for a temporary session environment for this notebook. The contents are largely converted from my own =init.el=, from using =customize=-interface to using =setq=.

#+begin_src elisp
  ;; Don't confirm killing processes on exit
  (setq confirm-kill-processes nil)

  ;; Set UTF-8 as default encoding
  (set-language-environment "UTF-8")
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)

  ;; No hard tabs, set indentations for major langs
  (setq indent-tabs-mode nil)
  (setq tab-width 4)
  (setq js-indent-level 2)
  (setq css-indent-level 2)

  ;; Initialize package system. Add MELPA.
  (setq package-archives
        '(("melpa"     . "https://melpa.org/packages/")
          ("elpa"      . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))

  ;; By default, always try to install missing packages, always defer loading until actually needed, disable verbose loading (enable for debugging).
  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
  (setq use-package-always-defer t)
  (setq use-package-verbose nil)

  ;; Org-mode
  (use-package org
    :load-path ("lisp/org-mode/lisp" "lisp/org-mode/lisp/contrib/lisp")
    :hook
    (org-babel-after-execute . org-redisplay-inline-images)
    :config
    )

  ;; nix-mode for syntax highlighting nix configuration files
  (use-package nix-mode
    :ensure t)
  ;; Haskell language & direnv support
  (use-package haskell-mode
    :ensure t)
  (use-package envrc
    :config
    (envrc-global-mode +1))
  (use-package eglot
    :config
    (add-hook 'haskell-mode-hook #'eglot-ensure)
    ;; Optionally add keybindings to some common functions:
    :bind ((:map eglot-mode-map
                 ("C-c C-e r" . eglot-rename)
                 ("C-c C-e l" . flymake-show-buffer-diagnostics)
                 ("C-c C-e p" . flymake-show-project-diagnostics)
                 ("C-c C-e C" . eglot-show-workspace-configuration)
                 ("C-c C-e R" . eglot-reconnect)
                 ("C-c C-e S" . eglot-shutdown)
                 ("C-c C-e A" . eglot-shutdown-all)
                 ("C-c C-e a" . eglot-code-actions)
                 ("C-c C-e f" . eglot-format))))

  ;; Allow in-place language execution for Latex, Python, Haskell, and shell languages.
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'org-babel-tangle
                            :append :local)))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell   . t)
     (haskell . t)
     (emacs-lisp   . t)))
  (setq haskell-process-type 'ghci)

  (use-package org-indent
    :ensure nil
    :diminish)

  ;; Enable navigating via a table of contents in a side buffer
  (use-package org-sidebar
    :ensure t)
  (add-hook 'org-mode-hook 'org-sidebar-tree-toggle)

  ;; Hide emphasis markers
  (setq org-hide-emphasis-markers t)

  ;; Font-lock substitution for list markers
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))

  ;; org-bullets
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  ;; Mode-specific bookmarks
  ;; `M-i` to jump in eg. org-mode to select heading in a list of headings.
  (use-package imenu-anywhere
    :bind
    ("M-i" . helm-imenu-anywhere))

  ;; miscellaneous
  (use-package poet-theme
    :ensure t)
  (load-theme 'poet t)
  (setq sentence-end-double-space nil)
#+end_src

To run frontend visualizations =ob-html-chrome= is recommended. A Chromium browser is required.
#+begin_src elisp :results silent
  (use-package ob-html-chrome
    :ensure t)
  (require 'ob-html-chrome)
  (setq org-babel-html-chrome-chrome-executable
    "/usr/bin/chromium-browser")
#+end_src

To open tangled files with =C-c C-o= on a tangled code block. /Is not transitive via noweb: works only with root blocks with :tangle set/
#+begin_src elisp :results silent
  (defun ibizaman/org-babel-goto-tangle-file ()
      (if-let* ((args (nth 2 (org-babel-get-src-block-info t)))
                (tangle (alist-get :tangle args)))
          (when (not (equal "no" tangle))
            (find-file tangle)
            t)))

  (add-hook 'org-open-at-point-functions 'ibizaman/org-babel-goto-tangle-file)
#+end_src

** Setup IHP and the initial project
[a short introduction into what IHP does and what is it's working ethos.]

#+begin_src shell :results silent :dir .
  nix-env --install ihp-new
#+end_src

IHP uses nix "flakes" which require special handling when used inside git repositories like the one this notebook is in ([[https://github.com/NixOS/nix/issues/6642][nix issue #6642]], [[https://github.com/digitallyinduced/ihp/issues/1787][ihp issue #1787]]). To work around this issue, a git repository has to be created for the IHP program. As of writing this, nix still used the old =ihp-new=, so this notebook is accompanied by the =ihp-new= @ commit 016a14d. =ihp-new= will initialize git repository with default credentials and options.

Setting an IHP project up for the first time can take a long time, is verbose, and asks if precompiled binaries can be used. Thus, it is preferable to run it in a separate terminal without piping =yes=. If using precompiled binaries is fine,  it can be run inside the notebook:
#+begin_src shell :results silent :dir .
  yes | ./ihp-new liikuntakirja
#+end_src

With the project set up, this document should now be tangled with  =C-c C-v t= (=org-babel-tangle=).

The following assets are needed inside the program:
#+begin_src shell :results silent :dir .
  cp assets/chart.umd.min.js liikuntakirja/static/
#+end_src

If editing the code, setting the editor to save on unfocus and to tangle on save smoothens the experience. Combined with IHP's reactive coding via autoreloading, it tightens the interactive loop.
#+begin_src elisp
  ;; Tangle on save
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'org-babel-tangle
                            :append :local)))
  ;; Save on unfocus
  (defun save-all ()
    (interactive)
    (save-some-buffers t))
  (add-hook 'focus-out-hook 'save-all)
#+end_src

** Project configuration
Org-babel's Haskell interface leans on hcky pattern matching. To get =ob-haskell= to execute Haskell blocks, we have to amend the default =.ghci= file with the default =ghci= prompt (=ghci>=), instead of the one set by IHP (=IHP>=).
#+caption: Set default GHCi prompt
#+begin_src haskell :noweb-ref Set default GHCi prompt
  :set prompt "ghci> "
#+end_src

#+caption: The IHP-provided .ghci with our amendment
#+begin_src haskell :tangle liikuntakirja/.ghci
  :set -XNoImplicitPrelude
  :def loadFromIHP \file -> (System.Environment.getEnv "IHP_LIB") >>= (\ihpLib -> readFile (ihpLib <> "/" <> file))
  :loadFromIHP applicationGhciConfig
  import IHP.Prelude
  <<Set default GHCi prompt>>
#+end_src

Any external programs or Haskell libraries should be added into the =flake.nix= which reproducibly builds the software environment for the program for any new deployment.
#+caption: Flake configuration
#+begin_src nix :tangle liikuntakirja/flake.nix
  {
      inputs = {
          ihp.url = "github:digitallyinduced/ihp/v1.2";
          nixpkgs.follows = "ihp/nixpkgs";
          flake-parts.follows = "ihp/flake-parts";
          devenv.follows = "ihp/devenv";
          systems.follows = "ihp/systems";
      };

      outputs = inputs@{ self, nixpkgs, ihp, flake-parts, systems, ... }:
          flake-parts.lib.mkFlake { inherit inputs; } {

              systems = import systems;
              imports = [ ihp.flakeModules.default ];

              perSystem = { pkgs, ... }: {
                  ihp = {
                      enable = true;
                      projectPath = ./.;
                      packages = with pkgs; [
                          # Native dependencies, e.g. imagemagick
                      ];
                      haskellPackages = p: with p; [
                          # Haskell dependencies go here
                          p.ihp
                          cabal-install
                          base
                          wai
                          text
                          <<Haskell dependencies>>
                      ];
                  };

                  # Custom configuration that will start with `devenv up`
                  devenv.shells.default = {
                      # Start Mailhog on local development to catch outgoing emails
                      # services.mailhog.enable = true;

                      # Custom processes that don't appear in https://devenv.sh/reference/options/
                      processes = {
                          # Uncomment if you use tailwindcss.
                          # tailwind.exec = "tailwindcss -c tailwind/tailwind.config.js -i ./tailwind/app.css -o static/app.css --watch=always";
                      };
                  };
              };
          };
  }
#+end_src

Everything should now be set for both running the program and the untangled blocks of code in this notebook. The following block can be used to test if the environment is set up properly.
#+begin_src haskell :dir ./liikuntakirja
  :t config
#+end_src

Any code block results can be cleared per-block with =C-c C-v k= and globally using universal prefix (=C-u C-c C-v k=).

** Running the program
We will have to set the =Development= / =Production= flags and a proper host name for the global =config=. These are fine for development:
#+caption: Set development or production flags
#+begin_src haskell :noweb-ref Set development or production flags
  option Development
  option (AppHostname "localhost")
#+end_src
For deployment, following settings are used:
#+begin_src haskell
  option Production
  option (AppHostname "domain.tld")
#+end_src

The program is run either by running =devenv up= or the =start= script. The front page should open up in your default browser (via =xdg-open=) once the web server has started. User interfacing part runs on port 8000 and a development IDE on 8001.
#+begin_src shell :async yes :session *ihp* :dir ./liikuntakirja :results silent
  ./start
#+end_src

** Weaving this notebook
A =liikuntakirja.html= is produced in working directory and opened in your default browser with =C-c C-e h o=. For syntax highlighting, =htmlize= can be installed and will automatically hook on to the HTML export function.
#+begin_src elisp
  (use-package htmlize
    :ensure t)
#+end_src

** Unit testing
The project uses HSpec testing framework for unit tests.

#+name: Haskell dependencies
#+begin_src nix
hspec
#+end_src

#+begin_src haskell :tangle liikuntakirja/Test/Main.hs
  module Main where

  import Test.Hspec
  import IHP.Prelude

  import Test.Controller.ActivitiesSpec
  import Test.Application.TCXSpec

  main :: IO ()
  main = hspec do
      <<Unit test modules>>
#+end_src

#+name: Universal IHP unit testing imports
#+begin_src haskell
  import Network.HTTP.Types.Status
  import Data.Maybe (fromJust)

  import IHP.Prelude
  import IHP.QueryBuilder (query)
  import IHP.Test.Mocking
  import IHP.Fetch

  import IHP.FrameworkConfig
  import IHP.HaskellSupport
  import Test.Hspec
  import Config
  import Generated.Types
#+end_src

#+caption: Unit test module (Activities controller)
#+begin_src haskell :noweb-ref Unit test modules
  Test.Controller.ActivitiesSpec.tests
#+end_src
#+begin_src haskell :tangle liikuntakirja/Test/Controller/ActivitiesSpec.hs
  module Test.Controller.ActivitiesSpec where

  <<Universal IHP unit testing imports>>

  import Web.Routes
  import Web.Types
  import Web.Controller.Activities (convertTcxActivityToWebActivity)
  import Web.FrontController ()
  import Network.Wai
  import IHP.ControllerPrelude
  import Application.TCX (processTcxFile)

  tests :: Spec
  tests = aroundAll (withIHPApp WebApplication config) do
          describe "ActivitiesController" $ do
            it "has no existing activities" $ withContext do
              count <- query @Activity
                       |> fetchCount
              count `shouldBe` 0
            <<Test converting TcxActivity into database records>>
#+end_src

With the framework set up, we can now run all the tests by loading Main and running =main=.
#+begin_src haskell
  :l Test/Main
  main
#+end_src

#+RESULTS:


* The Liikuntakirja story
#+PROPERTY:header-args :dir ./liikuntakirja :mkdirp yes :exports code :noweb no-export
Liikuntakirja is a story of a person wanting to upload, view, edit, and delete their workout sessions originally recorded on a smartwatch. The universal fitness trackers found on market are too complex to use and make compromises to cover all bases. These don't cater to tracking the user's workout sessions in a minimalistic way.

The user is happy with a unified interface. A workout session can be selected from a drop-down menu and a new one can be uploaded by browsing their computer. At the same time the data from either the newest upload or the one specially selected from the drop-down is shown.

This document will lead us from the perspective of a user using the software artefact. The user will first see the front page with all added activities indexed. They will then move on to add an activity. Then they will examine the added activity. After that the activity will be deleted as unsatisfactory.

A set of tests will be derived from the story and the code derived from those will be dispersed there on a need-to-know basis, which means all of the boilerplate that doesn't fit in can be found as an appendix. The boilerplate should only have to be edited when refactoring the code or the test suite.

** User accesses Liikuntakirja via browser
Since the user is only interested in activities, we can do everything via =ActivitiesController=. =Activity= is a data structure signifying a single workout. It is examined closer in the next chapter. =ActivitiesController= produces a =View= depending on the =Action=. Multiple =Actions= can lead to the same =View=, like =ActivitiesAction= and =DeleteActivityAction= will both end up rendering the indexing =View=.
#+caption: Activities controller type constructors
#+begin_src haskell :noweb-ref Activities controller type constructors
  data ActivitiesController
      = ActivitiesAction
      | NewActivityAction
      | ShowActivityAction { activityId :: !(Id Activity) }
      | CreateActivityAction
      | DeleteActivityAction { activityId :: !(Id Activity) }
      deriving (Eq, Show, Data)
#+end_src
#+caption: Set ActivitiesAction as front page
#+begin_src haskell :noweb-ref Set ActivitiesAction as front page
  startPage ActivitiesAction
#+end_src

=ActivitiesAction= will query all activities from the database:
#+caption: Index Activities using IndexView
#+begin_src haskell :noweb-ref Index Activities using IndexView
  action ActivitiesAction = do
    activities <- query @Activity |> fetch
    render IndexView { .. }
#+end_src
And =IndexView= will then list the activities. IHP uses JSX-like HSX syntax. It enables embedding Haskell code inside page layouts.
#+caption: An IHP boilerplate for a View instance, IndexView in this case.
#+begin_src haskell :tangle liikuntakirja/Web/View/Activities/Index.hs
  module Web.View.Activities.Index where
  import Web.View.Prelude

  data IndexView = IndexView { activities :: [Activity] }

  instance View IndexView where
      html IndexView { .. } = [hsx|
          <<Lay out the Activities index page>>
      |]
          where
              breadcrumb = renderBreadcrumb
                  [ breadcrumbLink "Activities" ActivitiesAction
                  ]

  renderActivity :: Activity -> Html
  renderActivity activity = [hsx|
      <<Lay out the individual Activity for indexing>>
  |]
#+end_src
#+caption: Lay out the Activities index page
#+begin_src html :noweb-ref Lay out the Activities index page
  {breadcrumb}

  <<Lay out the headline and new Activity button>>
  <div class="table-responsive">
    <table class="table">
      <thead>
        <tr>
          <th>Activity</th>
          <th></th>
          <th></th>
          <th></th>
        </tr>
      </thead>
      <tbody>{forEach activities renderActivity}</tbody>
    </table>

  </div>
#+end_src
#+caption: Lay out the individual Activity for indexing
#+begin_src html :noweb-ref Lay out the individual Activity for indexing
  <tr>
    <td>{activity}</td>
    <td><a href={ShowActivityAction activity.id}>Show</a></td>
    <td><a href={DeleteActivityAction activity.id} class="js-delete text-muted">Delete</a></td>
  </tr>
#+end_src

To add an Activity, the user finds the 'New' button found on the headline:
#+caption: Lay out the headline and new Activity button
#+begin_src html :noweb-ref Lay out the headline and new Activity button
  <h1>Index<a href={pathTo NewActivityAction} class="btn btn-primary ms-4">+ New</a></h1>
#+end_src

** User uploads smartwatch data into Liikuntakirja
The user has TCX-formatted smartwatch data files on their computer, ready for uploading.
*** Uploading into database
To allow user uploads to =static/= directory, we'll have to import a configuration and some flags in =Config.hs= defined at Configure IHP
#+caption: Import upload configuration
#+begin_src haskell :noweb-ref Import upload configuration
  import IHP.FileStorage.Config
#+end_src
#+caption: Allow uploads
#+begin_src haskell :noweb-ref Allow uploads
  initStaticDirStorage
#+end_src

A simple file upload form is enough, everything in =Activity= can be derived from the uploaded TCX file.
#+caption: Lay out Activity upload form
#+begin_src html :noweb-ref Lay out Activity upload form
  {(fileField #uploadUrl) { required = True }}
  {submitButton}
#+end_src
The page for uploading the new =Activity= is kept simple. *TODO:* should be integrated into =IndexView= for unified interface as requested.
#+caption: A View instance for NewView
#+begin_src haskell :tangle liikuntakirja/Web/View/Activities/New.hs
  module Web.View.Activities.New where
  import Web.View.Prelude

  data NewView = NewView { activity :: Activity }

  instance View NewView where
      html NewView { .. } = [hsx|
          <<Lay out new Activity page>>
      |]
          where
              breadcrumb = renderBreadcrumb
                  [ breadcrumbLink "Activities" ActivitiesAction
                  , breadcrumbText "New Activity"
                  ]

  renderForm :: Activity -> Html
  renderForm activity = formFor activity [hsx|
      <<Lay out Activity upload form>>
  |]
#+end_src
#+caption: Lay out new Activity page
#+begin_src html :noweb-ref Lay out new Activity page
  {breadcrumb}
  <h1>New Activity</h1>
  {renderForm activity}
#+end_src

Once the user clicks "Upload", we will pass the uploaded TCX for conversion.
*** Converting the uploaded TCX file
When the user submits the form, the file arrives at the respective =ActivitiesController= action. User will be redirected back to the front page. In between, the TCX file is converted into an intermediate =TcxActivity= and finally to =Activity= compatible with our database setup.
#+caption: Create Activity from uploaded TCX
#+begin_src haskell :noweb-ref Create Activity from uploaded TCX
  action CreateActivityAction = do
    <<Convert uploaded TCX into TcxActivity>>
    convertTcxActivityToWebActivity tcx
    setSuccessMessage ("Activity uploaded!")
    redirectTo ActivitiesAction
#+end_src
The TCX file we've received is an XML-formatted file. In the file, Trackpoints are of most interest as it keeps track of heart rate, speed and time, but Lap and Activity have some useful metadata too. An example TCX produced by a 5-second workout.
#+caption: TCX XML for a simple unit test
#+begin_src xml :tangle liikuntakirja/test.tcx
<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2">
  <Activities>
    <Activity Sport="Other">
      <Id>2024-03-19T12:28:24.470Z</Id>
      <Lap StartTime="2024-03-19T12:28:25.470Z">
        <TotalTimeSeconds>5.0</TotalTimeSeconds>
        <DistanceMeters>0.0</DistanceMeters>
        <Calories>1</Calories>
        <AverageHeartRateBpm>
          <Value>61</Value>
        </AverageHeartRateBpm>
        <MaximumHeartRateBpm>
          <Value>62</Value>
        </MaximumHeartRateBpm>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>
          <Trackpoint>
            <Time>2024-03-19T12:28:25.470Z</Time>
            <DistanceMeters>0.0</DistanceMeters>
            <HeartRateBpm>
              <Value>62</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:26.470Z</Time>
            <DistanceMeters>0.0</DistanceMeters>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:27.470Z</Time>
            <DistanceMeters>0.0</DistanceMeters>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:28.470Z</Time>
            <DistanceMeters>0.0</DistanceMeters>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:29.470Z</Time>
            <DistanceMeters>0.0</DistanceMeters>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
        </Track>
      </Lap>
      <Training VirtualPartner="false">
        <Plan Type="Workout" IntervalWorkout="false">
          <Extensions/>
        </Plan>
      </Training>
      <Creator xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Device_t">
        <Name>Polar INW3N_V2</Name>
        <UnitId>0</UnitId>
        <ProductID>0</ProductID>
        <Version>
          <VersionMajor>0</VersionMajor>
          <VersionMinor>0</VersionMinor>
          <BuildMajor>0</BuildMajor>
          <BuildMinor>0</BuildMinor>
        </Version>
      </Creator>
    </Activity>
  </Activities>
  <Author xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Application_t">
    <Name>https://github.com/cmaion/polar</Name>
    <Build>
      <Version>
        <VersionMajor>0</VersionMajor>
        <VersionMinor>0</VersionMinor>
      </Version>
    </Build>
    <LangID>EN</LangID>
    <PartNumber>XXX-XXXXX-XX</PartNumber>
  </Author>
</TrainingCenterDatabase>
#+end_src
The following type structures are directly derived from this XML structure with irrelevant data pruned out. We end up with a tree structure going from Activity, to Lap, to Trackpoint. Intermediate types are prefixed by 'Tcx' to avoid collisions with IHP's database-derived types. Intermediate types are used to easen the transition between top-down tree structure idiomatic to Haskell records and bottom-up tree structures idiomatic to relational databases. Activity type for conversion:
#+caption: TcxActivity
#+begin_src haskell :noweb-ref TcxActivity
  data TcxActivity = TcxActivity
    { tcxLaps :: [TcxLap]
    , tcxSport :: Text
    , tcxActStart :: UTCTime
    , tcxPlanType :: Text
    , tcxDeviceName :: Text
    } deriving (Eq, Show)
#+end_src
And the database schema derived from it:
#+caption: Activity schema
#+begin_src sql :noweb-ref Activity schema
  CREATE TABLE activities (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      sport TEXT NOT NULL,
      start_time TIMESTAMP WITH TIME ZONE NOT NULL,
      plan_type TEXT NOT NULL,
      device_name TEXT NOT NULL,
      upload_url TEXT NOT NULL
  );
#+end_src

Activities consist of one or more laps.
#+caption: TcxLap
#+begin_src haskell :noweb-ref TcxLap
  data TcxLap = TcxLap
    { tcxLapStart :: UTCTime
    , tcxLapTotal :: TotalTimeSec
    , tcxLapDistance :: DistanceMeters
    , tcxCals :: Calories
    , tcxAvgHR :: HeartRateBpm
    , tcxMaxHR :: HeartRateBpm
    , tcxIntensity :: Text
    , tcxTrigger :: Text
    , tcxTrack :: TcxTrack
    } deriving (Eq, Show)
#+end_src
#+caption: Lap schema
#+begin_src sql :noweb-ref Lap schema
  CREATE TABLE laps (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      activity_id UUID NOT NULL,
      start_time TIMESTAMP WITH TIME ZONE NOT NULL,
      total_time REAL NOT NULL,
      distance REAL NOT NULL,
      calories INT NOT NULL,
      average_hr INT NOT NULL,
      maximum_hr INT NOT NULL,
      intensity TEXT NOT NULL,
      "trigger" TEXT NOT NULL
  );
#+end_src

Laps in turn consist of tracks which are collections of trackpoints. We will assume any extra tracks can be concatenated into one single track to simplify the data model.
#+caption: TcxTrackpoint
#+begin_src haskell :noweb-ref TcxTrackpoint
  data TcxTrackpoint = TcxTrackpoint
    { tcxTpTime :: UTCTime
    , tcxTpDistance :: DistanceMeters
    , tcxTpHR :: HeartRateBpm
    , tcxSensor :: Text
    } deriving (Eq, Show)

  type TcxTrack = [TcxTrackpoint]
#+end_src
#+caption: Trackpoint schema
#+begin_src sql :noweb-ref Trackpoint schema
  CREATE TABLE trackpoints (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      lap_id UUID NOT NULL,
      point_time TIMESTAMP WITH TIME ZONE NOT NULL,
      distance REAL NOT NULL,
      hr INT NOT NULL,
      sensor TEXT NOT NULL
  );
#+end_src

We collect these along with some descriptive aliases into types for the application.
#+caption: Tcx types
#+begin_src haskell :noweb-ref Tcx types
  type TotalTimeSec = Float
  type DistanceMeters = Float
  type Calories = Int
  type HeartRateBpm = Int

  <<TcxTrackpoint>>

  <<TcxLap>>

  <<TcxActivity>>
#+end_src
#+caption: Tcx schema
#+begin_src sql :noweb-ref Tcx schema
  <<Activity schema>>
  <<Lap schema>>
  <<Trackpoint schema>>
#+end_src

The example TCX file should then parse into a structure like this.
#+caption: Simple TCX XML converted to a record
#+begin_src haskell
  [TcxActivity
   { tcxLaps =
       [ TcxLap
         { tcxLapStart = 2024-03-19 12:28:25.47 UTC
         , tcxLapTotal = 5.0
         , tcxLapDistance = 0.0
         , tcxCals = 1
         , tcxAvgHR = 61
         , tcxMaxHR = 62
         , tcxIntensity = "Active"
         , tcxTrigger = "Manual"
         , tcxTrack =
             [ TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:25.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 62
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:26.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:27.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:28.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             , TcxTrackpoint
               { tcxTpTime = 2024-03-19 12:28:29.47 UTC
               , tcxTpDistance = 0.0
               , tcxTpHR = 61
               , tcxSensor = "Present"
               }
             ]
         }
       ]
   , tcxSport = "Other"
   , tcxActStart = 2024-03-19 12:28:24.47 UTC
   , tcxPlanType = "Workout"
   , tcxDeviceName = "Polar INW3N_V2"
   }]
#+end_src

=TcxActivity='s =Show= instance should then produce this for the unit test comparison:
#+begin_src haskell :tangle liikuntakirja/test.tcx.result
  [TcxActivity {tcxLaps = [TcxLap {tcxLapStart = 2024-03-19 12:28:25.47 UTC, tcxLapTotal = 5.0, tcxLapDistance = 0.0, tcxCals = 1, tcxAvgHR = 61, tcxMaxHR = 62, tcxIntensity = "Active", tcxTrigger = "Manual", tcxTrack = [TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:25.47 UTC, tcxTpDistance = 0.0, tcxTpHR = 62, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:26.47 UTC, tcxTpDistance = 0.0, tcxTpHR = 61, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:27.47 UTC, tcxTpDistance = 0.0, tcxTpHR = 61, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:28.47 UTC, tcxTpDistance = 0.0, tcxTpHR = 61, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:29.47 UTC, tcxTpDistance = 0.0, tcxTpHR = 61, tcxSensor = "Present"}]}], tcxSport = "Other", tcxActStart = 2024-03-19 12:28:24.47 UTC, tcxPlanType = "Workout", tcxDeviceName = "Polar INW3N_V2"}]
#+end_src
We can now make a unit testing file for these conversions. Since the XML files are big and not trivially referenced in string form in Haskell, we'll load it from a file.
#+caption: TCX unit tests
#+begin_src haskell :tangle liikuntakirja/Test/Application/TCXSpec.hs
  module Test.Application.TCXSpec where
  import Test.Hspec
  import IHP.Prelude
  import Data.Time (UTCTime)
  import Data.Text.IO (readFile)
  import Text.Read (read)

  import Application.TCX
  import Web.Types

  tests :: Spec
  tests = do
    tcxToRecord

  tcxToRecord :: Spec
  tcxToRecord = do
    describe "processTcxFile" $ do
      it "can convert TCX file into TcxActivity" $ do
        convertedTcx <- processTcxFile "test.tcx"
        resultTcx <- readFile "test.tcx.result"
        (show convertedTcx ++ "\n") `shouldBe`
          resultTcx
#+end_src
#+caption: Unit test modules
#+begin_src haskell :noweb-ref Unit test modules
  Test.Application.TCXSpec.tests
#+end_src

First we'll convert the uploaded XML into the =TcxActivity= record type. TCX files can theoretically have multiple =Activities=, but they are not expected in this case. Neither is graceful exception handling required due to threaded nature of IHP and the singular purpose of the upload request, so using =fromJust= as a shortcut is fine for now.
#+caption: Convert uploaded TCX into TcxActivity
#+begin_src haskell :noweb-ref Convert uploaded TCX into TcxActivity
  let tcx :: TcxActivity =
        fileOrNothing "uploadUrl"
        |> fromMaybe (error "no file given")
        |> (.fileContent)
        |> cs
        |> processTcxUpload
        |> head
        |> fromJust
#+end_src

The external functions used in these conversions. Using =fromJust= is fine, since we can expect XML to be correctly formed and in malformed cases the silent =error= is not an issue. The service will keep on running in these cases.
#+caption: Import TCX conversion functions
#+begin_src haskell :noweb-ref Import TCX conversion functions
  import Application.TCX (processTcxUpload)
  import Data.Maybe (fromJust)
#+end_src

Since there are no libraries available for directly extracting the TCX format, we'll construct a filter chain using =xml-conduit= (Text.XML and Text.XML.Cursor).
#+caption: Haskell dependencies
#+begin_src nix :noweb-ref Haskell dependencies
xml-conduit
#+end_src

#+caption: Application.TCX prologue
#+begin_src haskell :tangle liikuntakirja/Application/TCX.hs
  {-# LANGUAGE OverloadedStrings #-}

  module Application.TCX (processTcxFile, processTcxUpload) where

  import Data.Maybe (fromJust)
  import Data.Text (Text)
  import qualified Data.Text as T
  import qualified Data.Text.Lazy as TL
  import qualified Data.Text.Lazy.IO as TLIO
  import Data.Time (UTCTime)
  import Data.Time.Format.ISO8601 (formatParseM, iso8601Format)
  import Text.XML
  import Text.XML.Cursor

  import IHP.Prelude
  import Text.Read
  import Web.Types

  <<Key TCX functions>>

  <<The TCX inner works>>
#+end_src

There are two entry points to this TCX extractor: =processTcxFile= and =processTcxUpload=. Either approach would be fine with IHP's file uploading routine, but converting from =Text= rather than from =FilePath= inside =IO= monad is more straightforward. XML extractors like /Haskell XML Toolkit/ only work with files, so having =processTcxFile= is fulfilling idiomatic expectations, but also enables testing with larger files.
#+caption: Key TCX functions
#+begin_src haskell :noweb-ref Key TCX functions
  processTcxFile :: FilePath -> IO [TcxActivity]
  processTcxFile file = processTcx <$> TLIO.readFile file

  processTcxUpload :: Text -> [TcxActivity]
  processTcxUpload = processTcx . TL.pack . T.unpack

  processTcx :: TL.Text -> [TcxActivity]
  processTcx = getActivities . fromDocument . parseText_ def
#+end_src

Extracting the fields in this case is logically simple if repetitive and verbose. It could be cleaned up with some helper functions. =read= is used, but as before, graceful exception handling is not required here, although could be relatively easily added since the return value of =[TcxActivity]= is essentially a =Maybe= structure.
#+caption: The TCX inner works
#+begin_src haskell :noweb-ref The TCX inner works
  getActivities :: Cursor -> [TcxActivity]
  getActivities cr =
    let activitiesCr = child cr >>= laxElement "Activities" >>= child >>= laxElement "Activity"
    in map getActivity activitiesCr

  getActivity :: Cursor -> TcxActivity
  getActivity cr =
    let lapsCr = child cr >>= laxElement "Lap"
        startTime = readTime . T.concat $ child cr >>= laxElement "Id" >>= descendant >>= content
    in TcxActivity
       (map getLap lapsCr)
       (T.concat $ attribute "Sport" cr)
       startTime
       (T.concat $ child cr >>= laxElement "Training" >>= child >>= laxElement "Plan" >>= attribute "Type")
       (T.concat $ child cr >>= laxElement "Creator" >>= child >>= laxElement "Name" >>= child >>= content)

  getLap :: Cursor -> TcxLap
  getLap cr =
    let tracksCr = child cr >>= laxElement "Track" >>= child >>= laxElement "Trackpoint"
    in TcxLap
       (readTime . T.concat $ attribute "StartTime" cr)
       (readContent $ child cr >>= laxElement "TotalTimeSeconds" >>= child >>= content)
       (readContent $ child cr >>= laxElement "DistanceMeters" >>= child >>= content)
       (readContent $ child cr >>= laxElement "Calories" >>= child >>= content)
       (readContent $ child cr >>= laxElement "AverageHeartRateBpm" >>= child >>= laxElement "Value" >>= child >>= content)
       (readContent $ child cr >>= laxElement "MaximumHeartRateBpm" >>= child >>= laxElement "Value" >>= child >>= content)
       (T.concat $ child cr >>= laxElement "Intensity" >>= child >>= content)
       (T.concat $ child cr >>= laxElement "TriggerMethod" >>= child >>= content)
       (map getTrackpoint tracksCr)

  getTrackpoint :: Cursor -> TcxTrackpoint
  getTrackpoint cr =
    TcxTrackpoint
    (readTime . T.concat $ child cr >>= laxElement "Time" >>= child >>= content)
    (readContent $ child cr >>= laxElement "DistanceMeters" >>= child >>= content)
    (readContent $ child cr >>= laxElement "HeartRateBpm" >>= child >>= laxElement "Value" >>= child >>= content)
    (T.concat $ child cr >>= laxElement "SensorState" >>= child >>= content)

  readContent :: (Read a) => [Text] -> a
  readContent = read . T.unpack . T.concat

  readTime :: Text -> UTCTime
  readTime = fromJust . formatParseM iso8601Format . T.unpack
#+end_src

Having put all this together, we can now convert a TCX file into a Haskell record structure:
#+begin_src haskell
  :l Test/Main
  hspec $ Test.Application.TCXSpec.tcxToRecord
#+end_src

Then we can do a type conversion similar to the one we did in when reading the XML: converting from the intermediate =TcxActivity= into the =Activity=  and others, which are then saved in the database via =createRecord= and its merged INSERT variation =createMany=. IHP will then be using =Activity=, =Lap= and =Trackpoint= in the views.
#+caption: Test converting TcxActivity into database records
#+begin_src haskell :noweb-ref Test converting TcxActivity into database records
  it "adds a TCX upload successfully into database" $ withContext do
    tcx <- fromJust . head <$> processTcxFile "test.tcx"
    convertTcxActivityToWebActivity tcx
    actCount <- query @Activity |> fetchCount
    actCount `shouldBe` 1
    lapCount <- query @Lap |> fetchCount
    actCount `shouldBe` 1
    tpCount <- query @Trackpoint |> fetchCount
    tpCount `shouldBe` 5
#+end_src
#+caption: Convert TcxActivity into Activity and other database records
#+begin_src haskell :noweb-ref Convert TcxActivity into Activity and other database records
  convertTcxActivityToWebActivity tcx = do
    activity <- newRecord @Activity
                |> set #sport (tcxSport tcx)
                |> set #startTime (tcxActStart tcx)
                |> set #planType (tcxPlanType tcx)
                |> set #deviceName (tcxDeviceName tcx)
                |> createRecord
    laps <- createMany $ map (\lap -> newRecord @Lap
                                      |> set #activityId (unpackId activity.id)
                                      |> set #startTime (tcxLapStart lap)
                                      |> set #totalTime (tcxLapTotal lap)
                                      |> set #distance (tcxLapDistance lap)
                                      |> set #calories (tcxCals lap)
                                      |> set #averageHr (tcxAvgHR lap)
                                      |> set #maximumHr (tcxMaxHR lap)
                                      |> set #intensity (tcxIntensity lap)
                                      |> set #trigger (tcxTrigger lap)
                             ) (tcxLaps tcx)
    let lapIdsWithTracks = zip (map (.id) laps) (map tcxTrack $ tcxLaps tcx)
    mapM_ (\(lapId, tcks) ->
             createMany $ map (\tck -> newRecord @Trackpoint
                                       |> set #lapId (unpackId lapId)
                                       |> set #pointTime (tcxTpTime tck)
                                       |> set #distance (tcxTpDistance tck)
                                       |> set #hr (tcxTpHR tck)
                                       |> set #sensor (tcxSensor tck)
                              ) tcks
          ) lapIdsWithTracks
#+end_src

These two conversions then come together and with the results saved into database with =createRecord= and =createMany= earlier, we can congratulate the user and move them into the Activities index. *TODO: we'll move the user to the uploaded activity*

** User looks at an activity
*** Plotting the activity
We'll be using an external =chart.js= library for plotting the data points. We'll amend =Web/View/Layout.hs= to include it.
#+caption: Import plotting library
#+begin_src html :noweb-ref Import JavaScript libraries
  <script src={assetPath "/chart.umd.min.js"}></script>
#+end_src

+A filled line chart is the weapon of choice for the heart rate over time chart, since its integral (area) could be seen as useful (total heart beats).+ A scatter chart is used for simpler =tick= handling inside chart.js. The chart type is subject to change.
#+caption: Plot heart rate
#+begin_src js :noweb-ref Plot heart rate
  <script data-hr={show heartRateList} data-time={show timeList}>
    var ctx = document.getElementById("hrChart").getContext('2d');
    var myChart = new Chart(ctx, {
      type: 'scatter',
      data: {
        labels: JSON.parse(document.currentScript.dataset.time),
        datasets: [{
          label: 'Heart rate',
          data: JSON.parse(document.currentScript.dataset.hr),
          fill: true,
          borderColor: 'rgb(75, 192, 192)',
          tension: 0.1
        }]
      },
      options: {
        scales: {
          y: {
            suggestedMin: 0,
            title: {
              display: true,
              text: 'BPM'
            }
          },
          x: {
            title: {
              display: true,
              text: 'Seconds'
            }
          }
        }
      }
    });
  </script>
#+end_src
#+caption: Map heart rate plot values
#+begin_src haskell :noweb-ref Map heart rate plot values
  heartRateList <- return $ map hr (concat tps)
  timeList <- return [0..length (concat tps) - 1]
#+end_src
#+caption: Add heart rate plot values as parameters
#+begin_src haskell :noweb-ref Add heart rate plot values as parameters
  , heartRateList :: [Int]
  , timeList :: [Int]
#+end_src
#+caption: Show plotted heart rate
#+begin_src html :noweb-ref Show plotted heart rate
  <div style="width: 800px;"><canvas id="hrChart"></canvas></div>
#+end_src

*TODO:* test the plot out by screenshotting a headless Chrome instance with =ob-html-chrome=. Blaze-kirjastolla saanee Web.View.Showista ulos dokumentin. MikÃ¤li HSpec tms meiningit ei tuo siistimpÃ¤Ã¤ ratkaisua. =cs . responseBody= voi olla hyÃ¶dyllinen =Html -> Text= tjsp. Ohjelman kontekstia ei kannata ajaa kun se on liian tyÃ¶lÃ¤stÃ¤ (ja selaimesta nÃ¤kee helposti), mutta yksittÃ¤isiÃ¤ elementtejÃ¤ voisi testata kuitenkin muuten blankossa leiskassa. HSX substituutiot pitÃ¤isi pystyÃ¤ jollain ilveellÃ¤ tekemÃ¤Ã¤n kyllÃ¤ ettÃ¤ tÃ¤ssÃ¤ on jÃ¤rkeÃ¤.

*** Fetching activity data and showing it
We'll first have to fetch data from the database, namely the =Activity=, =Laps=, and =Trackpoints=.
#+caption: Query Activity and its children
#+begin_src haskell :noweb-ref Query Activity and its children
  queryActivityAndItsChildren activityId = do
    activity <- fetch activityId
    laps <- query @Lap
            |> filterWhere (#activityId, unpackId activity.id)
            |> orderBy #startTime
            |> fetch
    tps <- mapM (\lap -> query @Trackpoint
                         |> filterWhere (#lapId, unpackId lap.id)
                         |> orderBy #pointTime
                         |> fetch
                ) laps
    return (activity, laps, tps)
#+end_src

#+caption: Show an activity
#+begin_src haskell :noweb-ref Show an activity
  action ShowActivityAction { activityId } = do
    (activity, laps, tps) <- queryActivityAndItsChildren activityId
    <<Map heart rate plot values>>
    render ShowView { .. }
#+end_src

#+caption: ShowView definition
#+begin_src haskell :noweb-ref ShowView definition
  data ShowView = ShowView { activity :: Activity
                           , laps :: [Lap]
                           , tps :: [[Trackpoint]]
                           <<Add heart rate plot values as parameters>>
                           }
#+end_src

#+caption: Show detailed view of an activity
#+begin_src html :noweb-ref Show detailed view of an activity
  {breadcrumb}
  <h1>Show Activity</h1>
  <<Show plotted heart rate>>

  <<Plot heart rate>>
#+end_src

#+caption: A View instance for showing an activity.
#+begin_src haskell :tangle liikuntakirja/Web/View/Activities/Show.hs
  module Web.View.Activities.Show where
  import Web.View.Prelude

  <<ShowView definition>>

  instance View ShowView where
    html ShowView { .. } =
      [hsx|
            <<Show detailed view of an activity>>
            |]
      where
              breadcrumb = renderBreadcrumb
                              [ breadcrumbLink "Activities" ActivitiesAction
                              , breadcrumbText "Show Activity"
                              ]
#+end_src

** User deletes an activity
User has clicked delete button and confirmed deletion. Activity and its constituents will be remove from the database.
#+caption: Delete an activity
#+begin_src haskell :noweb-ref Delete an activity
  action DeleteActivityAction { activityId } = do
      (activity, laps, tps) <- queryActivityAndItsChildren activityId
      deleteRecord activity
      deleteRecords laps
      deleteRecords (concat tps)
      setSuccessMessage "Activity deleted"
      redirectTo ActivitiesAction
#+end_src

** Developer is curious about boilerplate
Every IHP program has a global configuration.
#+caption: Configure IHP
#+begin_src haskell :tangle liikuntakirja/Config/Config.hs
  module Config where

  import IHP.Prelude
  import IHP.Environment
  import IHP.FrameworkConfig
  <<Import upload configuration>>

  config :: ConfigBuilder
  config = do
    <<Set development or production flags>>
    <<Allow uploads>>
#+end_src

#+caption: Web types
#+begin_src haskell :tangle liikuntakirja/Web/Types.hs
  module Web.Types where

  import IHP.Prelude
  import IHP.ModelSupport
  import Generated.Types

  data WebApplication = WebApplication deriving (Eq, Show)

  data StaticController = WelcomeAction deriving (Eq, Show, Data)


  <<Tcx types>>

  <<Activities controller type constructors>>
#+end_src

#+caption: Universal helper functions
#+begin_src haskell :tangle liikuntakirja/Application/Helper/Controller.hs
  module Application.Helper.Controller where

  import IHP.ControllerPrelude

  -- Here you can add functions which are available in all your controllers
#+end_src

#+caption: Web routing
#+begin_src haskell :tangle liikuntakirja/Web/Routes.hs
  module Web.Routes where
  import IHP.RouterPrelude
  import Generated.Types
  import Web.Types

  -- Generator Marker
  instance AutoRoute StaticController
  <<Route Activities>>
#+end_src

#+caption: Master controller
#+begin_src haskell :tangle liikuntakirja/Web/FrontController.hs
  module Web.FrontController where

  import IHP.RouterPrelude
  import Web.Controller.Prelude
  import Web.View.Layout (defaultLayout)

  -- Controller Imports
  import Web.Controller.Static
  <<Import Activities>>

  instance FrontController WebApplication where
      controllers =
          [ <<Set ActivitiesAction as front page>>
          -- Generator Marker
          <<Parse Activities route>>
          ]

  instance InitControllerContext WebApplication where
      initContext = do
          setLayout defaultLayout
          initAutoRefresh
#+end_src

#+caption: SQL schema file
#+begin_src sql :tangle liikuntakirja/Application/Schema.sql
  -- Your database schema. Use the Schema Designer at http://localhost:8001/ to add some tables.
  <<Tcx schema>>
#+end_src

*** Activities controller
#+caption: Activities controller implementation
#+begin_src haskell :tangle liikuntakirja/Web/Controller/Activities.hs
  module Web.Controller.Activities where

  import Web.Controller.Prelude
  import Web.View.Activities.Index
  import Web.View.Activities.New
  import Web.View.Activities.Edit
  import Web.View.Activities.Show

  <<Import TCX conversion functions>>

  instance Controller ActivitiesController where
      <<Index Activities using IndexView>>

      action NewActivityAction = do
          let activity = newRecord
          render NewView { .. }

      <<Show an activity>>

      <<Create Activity from uploaded TCX>>

      <<Delete an activity>>

  buildActivity activity = activity
      |> fill @'["sport", "startTime", "planType", "deviceName"]

  <<Convert TcxActivity into Activity and other database records>>

  <<Query Activity and its children>>
#+end_src

#+caption: Route Activities
#+begin_src haskell :noweb-ref Route Activities
  instance AutoRoute ActivitiesController
#+end_src

#+caption: Import Activities
#+begin_src haskell :noweb-ref Import Activities
  import Web.Controller.Activities
#+end_src

#+caption: Parse Activities route
#+begin_src haskell :noweb-ref Parse Activities route
  , parseRoute @ActivitiesController
#+end_src

*** Javascript libraries, CSS stylesheets, meta tags and default layout
#+caption: JavaScript libraries
#+begin_src html :noweb-ref JavaScript libraries
  {when isDevelopment devScripts}
  <script src={assetPath "/vendor/jquery-3.6.0.slim.min.js"}></script>
  <script src={assetPath "/vendor/timeago.js"}></script>
  <script src={assetPath "/vendor/popper-2.11.6.min.js"}></script>
  <script src={assetPath "/vendor/bootstrap-5.2.1/bootstrap.min.js"}></script>
  <script src={assetPath "/vendor/flatpickr.js"}></script>
  <script src={assetPath "/vendor/morphdom-umd.min.js"}></script>
  <script src={assetPath "/vendor/turbolinks.js"}></script>
  <script src={assetPath "/vendor/turbolinksInstantClick.js"}></script>
  <script src={assetPath "/vendor/turbolinksMorphdom.js"}></script>
  <script src={assetPath "/helpers.js"}></script>
  <script src={assetPath "/ihp-auto-refresh.js"}></script>
  <script src={assetPath "/app.js"}></script>
  <<Import JavaScript libraries>>
#+end_src

#+caption: CSS stylesheets
#+begin_src html :noweb-ref CSS stylesheets
  <link rel="stylesheet" href={assetPath "/vendor/bootstrap-5.2.1/bootstrap.min.css"}/>
  <link rel="stylesheet" href={assetPath "/vendor/flatpickr.min.css"}/>
  <link rel="stylesheet" href={assetPath "/app.css"}/>
#+end_src

#+caption: Meta tags
#+begin_src html :noweb-ref Meta tags
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
  <meta property="og:title" content="App"/>
  <meta property="og:type" content="website"/>
  <meta property="og:url" content="TODO"/>
  <meta property="og:description" content="TODO"/>
  {autoRefreshMeta}
#+end_src

#+caption: Development scripts
#+begin_src html :noweb-ref Development scripts
<script id="livereload-script" src={assetPath "/livereload.js"} data-ws={liveReloadWebsocketUrl}></script>
#+end_src

#+caption: Default page layout
#+begin_src html :noweb-ref Default page layout
  <!DOCTYPE html>
  <html lang="en">
      <head>
          {metaTags}

          {stylesheets}
          {scripts}

          <title>{pageTitleOrDefault "App"}</title>
      </head>
      <body>
          <div class="container mt-4">
              {renderFlashMessages}
              {inner}
          </div>
      </body>
  </html>
#+end_src

#+caption: The defaultLayout definition
#+begin_src haskell :tangle liikuntakirja/Web/View/Layout.hs

  module Web.View.Layout (defaultLayout, Html) where

  import IHP.ViewPrelude
  import IHP.Environment
  import Generated.Types
  import IHP.Controller.RequestContext
  import Web.Types
  import Web.Routes
  import Application.Helper.View

  defaultLayout :: Html -> Html
  defaultLayout inner = [hsx|
  <<Default page layout>>
  |]

  -- The 'assetPath' function used below appends a `?v=SOME_VERSION` to the static assets in production
  -- This is useful to avoid users having old CSS and JS files in their browser cache once a new version is deployed
  -- See https://ihp.digitallyinduced.com/Guide/assets.html for more details

  stylesheets :: Html
  stylesheets = [hsx|
          <<CSS stylesheets>>
      |]

  scripts :: Html
  scripts = [hsx|
          <<JavaScript libraries>>
      |]

  devScripts :: Html
  devScripts = [hsx|
          <<Development scripts>>
      |]

  metaTags :: Html
  metaTags = [hsx|
      <<Meta tags>>
  |]
#+end_src
