#+OPTIONS: broken-links:t

* Developer's prologue
#+PROPERTY:header-args :dir . :mkdirp yes :exports code :noweb no-export :results silent :eval never-export
The prologue covers setting up this notebook and the Liikuntakirja exercise tracker program contained within. This notebook and its program has some special requirements that need to be accounted for.

** Setup notebook environment
The following can be executed for a temporary session environment for this notebook. Note that while =setq= is used for temporary effect (instead of =customize-variable=), =use-package= will install the packages for good. Code blocks like the one below are run with =C-c C-c=. For better readability, variable pitch text (=variable-pitch-mode=) and clearer headlines in style of [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][Zzamboni's Beautifying Org Mode in Emacs]] are recommended, but are excluded from this document for clarity. Regarding color schemes, e.g. =poet= theme might be easier on the eyes than the default.

#+caption: Example Emacs configuration
#+begin_src elisp :results silent
  ;; Don't confirm killing processes on exit
  (setq confirm-kill-processes nil)

  ;; Set UTF-8 as default encoding
  (set-language-environment "UTF-8")
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)

  ;; No hard tabs, set indentations for major langs
  (setq indent-tabs-mode nil)
  (setq tab-width 4)
  (setq js-indent-level 2)
  (setq css-indent-level 2)

  ;; Initialize package system. Add MELPA.
  (setq package-archives
        '(("melpa"     . "https://melpa.org/packages/")
          ("elpa"      . "https://elpa.gnu.org/packages/")))
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))

  ;; Install use-package, disable verbose loading.
  (when (not (package-installed-p 'use-package))
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-verbose nil)

  ;; Org-mode
  (use-package org
    :load-path ("lisp/org-mode/lisp" "lisp/org-mode/lisp/contrib/lisp")
    :hook
    (org-babel-after-execute . org-redisplay-inline-images)
    :config
    )

  ;; nix-mode for syntax highlighting nix configuration files
  (use-package nix-mode
    :ensure t)
  ;; Haskell language & direnv support
  (use-package haskell-mode
    :ensure t)
  (use-package envrc
    :config
    (envrc-global-mode +1))

  ;; C-c C-o to open tangled file from a code block with :tangle set.
  ;; (note: Noweb nodes without :tangle set cannot be opened this way)
  (defun ibizaman/org-babel-goto-tangle-file ()
    (if-let* ((args (nth 2 (org-babel-get-src-block-info t)))
              (tangle (alist-get :tangle args)))
        (when (not (equal "no" tangle))
          (find-file tangle)
          t)))
  (add-hook 'org-open-at-point-functions 'ibizaman/org-babel-goto-tangle-file)

  ;; eglot haskell IDE can be used within tangled files
  ;; (note: changes cannot be 'detangled' back to the notebook)
  (use-package eglot
    :config
    (add-hook 'haskell-mode-hook #'eglot-ensure)
    ;; Optionally add keybindings to some common functions:
    :bind ((:map eglot-mode-map
                 ("C-c C-e r" . eglot-rename)
                 ("C-c C-e l" . flymake-show-buffer-diagnostics)
                 ("C-c C-e p" . flymake-show-project-diagnostics)
                 ("C-c C-e C" . eglot-show-workspace-configuration)
                 ("C-c C-e R" . eglot-reconnect)
                 ("C-c C-e S" . eglot-shutdown)
                 ("C-c C-e A" . eglot-shutdown-all)
                 ("C-c C-e a" . eglot-code-actions)
                 ("C-c C-e f" . eglot-format))))

  ;; Allow in-place language execution for Latex, Python, Haskell, and shell languages.
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'org-babel-tangle
                            :append :local)))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell   . t)
     (haskell . t)
     (emacs-lisp   . t)))
  (setq haskell-process-type 'ghci)

  (use-package org-indent
    :ensure nil
    :diminish)

  ;; Enable navigating via a table of contents in a side buffer
  (use-package org-sidebar
    :ensure t)
  (add-hook 'org-mode-hook 'org-sidebar-tree-toggle)

  ;; Hide emphasis markers
  (setq org-hide-emphasis-markers t)

  ;; Font-lock substitution for list markers
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))

  ;; org-bullets
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  ;; Mode-specific bookmarks
  ;; `M-i` to jump in eg. org-mode to select heading in a list of headings.
  (use-package imenu-anywhere
    :bind
    ("M-i" . helm-imenu-anywhere))

  ;; show inline images
  (add-hook 'org-mode-hook 'org-display-inline-images)
  ;; miscellaneous
  (setq sentence-end-double-space nil)

  ;; enable scrollbar
  (scroll-bar-mode 1)
#+end_src

Every block that /does/ have =results= header can be executed. If you don't want to be yes/no prompted every time you execute a block, you can disable the prompt by
#+begin_src elisp :results silent
  (setq org-confirm-babel-evaluate nil)
#+end_src

Saving & tangling this file might induce a ~second long garbage collection operation as it makes ~50MB worth of data structures. Garbage collection threshold should be raised to e.g. 512 megabytes from the default ~800 kilobytes. Exact number depends on how much RAM is disposable while the Emacs process is running.
#+begin_src elisp :results silent
  (setq gc-cons-threshold (* 512 1024 1024)) ;; 512 MB
  ;; Garbage collect on unfocus to avoid noticeable stutter
  (add-function :after
                after-focus-change-function
                (lambda () (unless (frame-focus-state) (garbage-collect))))
#+end_src

To run frontend visualizations, a Chromium binary is required.
#+caption: Chromium binary
#+begin_src sh :noweb-ref Chromium binary
  /usr/bin/chromium-browser
#+end_src
Following options are used when calling browser binary. DPI is 96 by default.
#+caption: Chromium options
#+begin_src sh :noweb-ref Chromium options
  --headless --window-size=<<Testing viewport size>> --disable-gpu --screenshot --run-all-compositor-stages-before-draw --virtual-time-budget=200
#+end_src
The user's viewport is assumed as
#+caption: Testing viewport size
#+begin_src sh :noweb-ref Testing viewport size
  1920x1200
#+end_src

ImageMagick's =convert= is used to scale down the visualizations for viewability
#+caption: Post-process screenshot
#+begin_src sh :noweb-ref Post-process screenshot
  convert screenshot.png -resize <<Visualization size>>
#+end_src
Availability can be checked with =which=.
#+begin_src sh :results output replace
  which convert
#+end_src

Visualizations using an image file will be downscaled to following format
#+caption: Visualization size
#+begin_src sh :noweb-ref Visualization size
  640x400
#+end_src

To see the visualizations embedded in the notebook, inline images should be enabled.
#+begin_src elisp :results silent
  (org-toggle-inline-images)
#+end_src

If using Org 9.6 or earlier (=M-x org-version=), executing blocks that produce graphics will error when using indirect buffers (usually via =org-sidebar)=. This is fixed in yet-to-be-released Org 9.7 ([[https://git.savannah.gnu.org/cgit/emacs/org-mode.git/commit/lisp/ob-core.el?id=c730caf51][commit c730caf51]]). As a one-liner fix, it can also be hackily patched by hand in =ob-core.el= (not =.elc=) usually found in =/usr/share/emacs/[version number]/lisp/org/=.

** Weaving this notebook
A =liikuntakirja.html= can be produced in the working directory and opened in your default browser with =C-c C-e h o=. For syntax highlighting, =htmlize= can be installed, which automatically hooks on to the HTML export function.
#+begin_src elisp :results silent
  (use-package htmlize
    :ensure t)
#+end_src

However, this notebook might be better read via Emacs' interface, with things like =variable-pitch-mode=, =org-sidebar=, and a suitable theme set.

** Install IHP prerequisites
[[https://ihp.digitallyinduced.com/][Integrated Haskell Platform]] is a fairly opinionated batteries-included web framework. It follows an MVC design and includes live reloading plus reproducible development and deployment environments (a sandbox). PostgreSQL is used out of the box for the model and is installed inside the application's sandbox. The sandbox is done using Nix. Nix depends on Git, Curl, Make, and Direnv.

These steps have been derived from the [[https://ihp.digitallyinduced.com/Guide/installation.html][IHP guide]].
#+caption: An example shell command for Dnf package manager with Fedora repositories.
#+begin_src shell
  sudo dnf install git curl make direnv
#+end_src

Then we can install Nix. /Note: The Nix installer appends your terminal emulator configuration to enable Direnv support./
#+begin_src shell :results silent :dir .
  curl -L https://nixos.org/nix/install | sh
#+end_src

After running the install script, shell environment has to be reloaded. To brute force this, restart Emacs and the shell session it's running in. Sourcing your appended terminal emulator configuration can be enough if you know what you are doing.

** Setup IHP and the initial project
IHP uses a web application creation script they call =ihp-new= found in the Nix repositories.
#+begin_src shell :results silent :dir .
  nix-env --install ihp-new
#+end_src

However, IHP uses Nix "flake" architecture, which requires special handling when used inside git repositories like the one this notebook is in ([[https://github.com/NixOS/nix/issues/6642][nix issue #6642]], [[https://github.com/digitallyinduced/ihp/issues/1787][ihp issue #1787]]). To work around this issue, a separate git repository has to be created for the program itself. As of writing this, Nix repositories still had an outdated =ihp-new= lacking automatic git init, so a newer =ihp-new= (commit 016a14d) from IHP repository is bundled with this notebook. The newer one will initialize git repository using default credentials and options.

Setting an IHP project up for the first time can take a long time, is verbose, and asks if precompiled binaries can be used. Thus, it may be preferable to run it in a separate terminal without piping =yes=. If using precompiled binaries is fine and you don't want to see progress bars, it can be run inside the notebook:
#+begin_src shell :results silent :dir .
  yes | ./ihp-new liikuntakirja
#+end_src

With the project set up, this document should now be tangled with  =C-c C-v t= (=org-babel-tangle=).

The following assets are needed inside the program.
#+begin_src shell :results silent :dir .
  wget https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js -o ./liikuntakirja/static/ # frontend plotting library

#+end_src

If you intend to edit the code, setting the editor to save on unfocus and to tangle on save smoothens the experience. Combined with IHP's reactive coding (autoreloading), it tightens up the interactive loop.
#+begin_src elisp :results silent
  ;; Tangle on save
  (add-hook 'org-mode-hook
            (lambda () (add-hook 'after-save-hook #'org-babel-tangle
                            :append :local)))
  ;; Save on unfocus
  (defun save-all ()
    (interactive)
    (save-some-buffers t))
  (add-hook 'focus-out-hook 'save-all)
#+end_src

** Project configuration
Org Mode's Babel interfaces lean on regex pattern matching. To get =ob-haskell= to execute Haskell blocks properly, we have to amend the default =.ghci= file with the default =ghci= prompt (=ghci>=), instead of the one set by IHP (=IHP>=).
#+caption: Set default GHCi prompt
#+begin_src haskell :noweb-ref Set default GHCi prompt
  :set prompt "ghci> "
#+end_src

#+caption: .ghci
#+begin_src haskell :tangle liikuntakirja/.ghci
  :set -XNoImplicitPrelude
  :def loadFromIHP \file -> (System.Environment.getEnv "IHP_LIB") >>= (\ihpLib -> readFile (ihpLib <> "/" <> file))
  :loadFromIHP applicationGhciConfig
  import IHP.Prelude
  <<Set default GHCi prompt>>
#+end_src

Any external programs or Haskell libraries should be added into the =flake.nix= which reproducibly builds the software environment for the program for any new deployment.
#+caption: flake.nix
#+begin_src nix :tangle liikuntakirja/flake.nix
  {
      inputs = {
          ihp.url = "github:digitallyinduced/ihp/v1.2";
          nixpkgs.follows = "ihp/nixpkgs";
          flake-parts.follows = "ihp/flake-parts";
          devenv.follows = "ihp/devenv";
          systems.follows = "ihp/systems";
      };

      outputs = inputs@{ self, nixpkgs, ihp, flake-parts, systems, ... }:
          flake-parts.lib.mkFlake { inherit inputs; } {

              systems = import systems;
              imports = [ ihp.flakeModules.default ];

              perSystem = { pkgs, ... }: {
                  ihp = {
                      enable = true;
                      projectPath = ./.;
                      packages = with pkgs; [
                          # Native dependencies, e.g. imagemagick
                      ];
                      haskellPackages = p: with p; [
                          # Haskell dependencies go here
                          p.ihp
                          cabal-install
                          base
                          wai
                          text
                          <<Haskell dependencies>>
                      ];
                  };

                  # Custom configuration that will start with `devenv up`
                  devenv.shells.default = {
                      # Start Mailhog on local development to catch outgoing emails
                      # services.mailhog.enable = true;

                      # Custom processes that don't appear in https://devenv.sh/reference/options/
                      processes = {
                          # Uncomment if you use tailwindcss.
                          # tailwind.exec = "tailwindcss -c tailwind/tailwind.config.js -i ./tailwind/app.css -o static/app.css --watch=always";
                      };
                  };
              };
          };
  }
#+end_src

Every IHP program has a global =config=.
#+caption: Config/Config.hs
#+begin_src haskell :tangle liikuntakirja/Config/Config.hs
  module Config where

  import IHP.Prelude
  import IHP.Environment
  import IHP.FrameworkConfig
  <<Import upload configuration>>

  config :: ConfigBuilder
  config = do
    <<Set development or production flags>>
    <<Allow uploads>>
#+end_src

Everything should now be set for both running the program and the untangled blocks of code in this notebook. The following block can be used to test if the environment is set up properly. In this case we'll show the whole output and not just the evaluated result, so any compilation errors can be easily seen.
#+begin_src haskell :results output replace :dir ./liikuntakirja
  :t config
#+end_src

Any code block results can be cleared per-block with =C-c C-v k= (=org-babel-remove-result=) and globally using Emacs' universal prefix =C-u= (=C-u C-c C-v k=, =org-babel-remove-result-one-or-many=).

** Running the program
We will have to set the =Development= / =Production= flags and a proper host name in the global =config=. These are fine for development:
#+caption: Set development or production flags
#+begin_src haskell :noweb-ref Set development or production flags
  option Development
  option (AppHostname "localhost")
#+end_src
For deployment, following settings are then used:
#+begin_src haskell
  option Production
  option (AppHostname "domain.tld")
#+end_src

The development mode has nice things like live reloading.
#+caption: Development scripts
#+begin_src html :noweb-ref Development scripts
  <script id="livereload-script" src={assetPath "/livereload.js"} data-ws={liveReloadWebsocketUrl}></script>
#+end_src

The program is run either by running =devenv up= or the =start= script. The front page should open up in your default browser (via =xdg-open=) once the web server has started. [[http://localhost:8000/][The user interfacing part]] runs on port 8000 and [[http://localhost:8001/][the IHP  IDE]] on 8001. The program can be run in a separate session inside this notebook environment:
#+begin_src shell :results silent :async yes :session *ihp* :dir ./liikuntakirja
  ./start
#+end_src

Any tests in this notebook will require a running Liikuntakirja instance, as they use its database interface.

*This part is not used currently:* For running any =psql= prompts in the notebook, =*psql*= should be set up by executing the next block. It works around a =psql=-related "o: command not found" =ob-shell= parsing issue. Environment variables like LESS could also be set per-command.
#+begin_src sh :results silent :session *psql* :dir ./liikuntakirja
  export LESS=eFRX
  psql --host=$(pwd)/build/db app -c "\q"
#+end_src

If there are database issues (if the schema has been changed after first running =start=), database structure can be reformatted. Either format (migrate) it graphically in [[http://localhost:8001/][the IHP IDE]] or run:
#+begin_src sh :results silent :session *psql* :dir ./liikuntakirja
  make db
#+end_src

** Unit testing
The project uses HSpec testing framework for unit tests.
#+caption: Haskell dependencies
#+begin_src nix :noweb-ref Haskell dependencies
  hspec
#+end_src

Hspec is a straightforward unit testing suite. We'll set up a root testing file in =Test/Main.hs=.
#+caption: Test/Main.hs
#+begin_src haskell :tangle liikuntakirja/Test/Main.hs
  module Main where

  import Test.Hspec
  import IHP.Prelude

  <<Unit test modules>>
  import Test.Application.TCXSpec

  main :: IO ()
  main = hspec do
      <<Unit test module functions>>
#+end_src

#+caption: Import universal IHP unit testing libraries
#+begin_src haskell :noweb-ref Import universal IHP unit testing libraries
  import Network.HTTP.Types.Status
  import Data.Maybe (fromJust)

  import IHP.Prelude
  import IHP.QueryBuilder (query)
  import IHP.Test.Mocking
  import IHP.Fetch

  import IHP.FrameworkConfig
  import IHP.HaskellSupport
  import Test.Hspec
  import Config
  import Generated.Types
#+end_src

Liikuntakirja is mostly actuated via the =Activities= controller.
#+caption: Unit test modules
#+begin_src haskell :noweb-ref Unit test modules
  import Test.Controller.ActivitiesSpec
#+end_src
#+caption: Unit test module functions
#+begin_src haskell :noweb-ref Unit test module functions
  Test.Controller.ActivitiesSpec.tests
#+end_src
#+caption: Test/Controller/ActivitiesSpec.hs
#+begin_src haskell :tangle liikuntakirja/Test/Controller/ActivitiesSpec.hs
  module Test.Controller.ActivitiesSpec where

  <<Import universal IHP unit testing libraries>>

  import Web.Routes
  import Web.Types
  import Web.Controller.Activities (insertTcxActivity, queryActivityAndItsChildren, avgOver10s)
  import Web.FrontController ()
  import Network.Wai
  import IHP.ControllerPrelude

  import Data.Text (unpack)
  import Application.TCX (processTcxFile)
  import Test.Controller.HealthInformationsSpec (insertDefaultHealthInformation)

  tests :: Spec
  tests = aroundAll (withIHPApp WebApplication config) do
          describe "ActivitiesController" $ do
            it "has no existing activities" $ withContext do
              count <- query @Activity
                       |> fetchCount
              count `shouldBe` 0
          <<ActivitiesSpec test function calls>>

  <<Test inserting a record provided by Application.TCX into database>>
#+end_src

With the framework set up and the program running in the background (most unit tests require a running PostgreSQL instance), we can now run all the tests by loading Main and running =main=.
#+begin_src haskell :results value replace
  :l Test/Main
  main
#+end_src
* The Liikuntakirja story
#+PROPERTY:header-args :dir ./liikuntakirja :mkdirp yes :exports code :noweb no-export :eval never-export
Liikuntakirja is a story of a person wanting to upload, view, and delete their workout sessions originally recorded on a smartwatch. The universal fitness trackers found on market are too complex to use and make compromises to cover all bases. These don't cater to tracking the user's workout sessions in a minimalistic way. The user wants a tracker they can run on their own computer. The user uses =cmaion='s =polar= suite ([[https://github.com/cmaion/polar][GitHub repository]]) to interface and produce TCX files.

The user is happy with a unified single-page interface. An exercise session can be selected from a menu and a new one can be uploaded from their computer. At the same time the data from either the newest upload or the one specially selected from the drop-down is shown.

User wants personalized reports about how the metered heart rates matched the physical stress derived from their age. Per-activity, user wants to see their heart rate and possible moving speed, with total distance, and maximum and average heart rate over the activity.

#+caption: Client's UI mock-up
#+name: interface mock-up
[[./assets/mockup.png]]

This document will lead us from the perspective of a user using the software artefact. The user will first see the front page with all added activities indexed. They will then move on to add an activity. Then they will examine the added activity. After that the activity will be deleted as unsatisfactory.

A set of tests will be derived from the story and the code derived from those will be shown as needed, which means any boilerplate without a clear story component can be found in the epilogue. The boilerplate should only have to be edited when refactoring the code.

Since the user is only interested in activities, we can do essentially everything via =ActivitiesController=. =Activity= is a data structure signifying a single workout. It is examined closer when the user starts uploading their activities. =ActivitiesController= produces a =View= depending on the =Action=. Multiple =Actions= can lead to the same =View=, and in this program's case, since it is a unified single page interface, all =Actions= eventually lead to =IndexView=. The =IndexView= always indexes all the activities. We offer the user abilities to show the newest activity (=ActivitiesAction=) or a specific activity (=ShowActivityAction=) with the index. User can also upload (=CreateActivityAction=) and delete (=DeleteActivityAction=) activities.
#+caption: Type ActivitiesController
#+begin_src haskell :noweb-ref Type ActivitiesController
  data ActivitiesController
      = ActivitiesAction
      | ShowActivityAction { activityId :: !(Id Activity) }
      | CreateActivityAction
      | DeleteActivityAction { activityId :: !(Id Activity) }
      deriving (Eq, Show, Data)
#+end_src

All these actions correspond to a function in =Controller ActivitiesController= type class instance, which acts the main hub of =Activity=-specific handling.
#+caption: Web/Controller/Activities.hs
#+begin_src haskell :tangle liikuntakirja/Web/Controller/Activities.hs
  module Web.Controller.Activities where

  import Web.Controller.Prelude
  import Web.View.Activities.Index

  import IHP.ModelSupport (Id')
  import Data.Text (pack, unpack)
  import qualified Data.Text as T

  <<Import TCX conversion functions>>
  <<Import Data.Time for sculpting ChartData>>

  instance Controller ActivitiesController where
      <<Index Activities using IndexView>>

      <<Show an activity>>

      <<Create Activity from uploaded TCX>>

      <<Delete an activity>>

  buildActivity activity = activity
      |> fill @'["sport", "startTime", "planType", "deviceName"]

  <<Convert TcxActivity into Activity and other database records>>

  <<Query Activity and its children>>

  <<Sculpt Activity into ChartData>>
#+end_src
We'll use default routing options and have =Web.Controller.Activities= imported to =Web.FrontController=.
#+caption: Controller routing instances
#+begin_src haskell :noweb-ref Controller routing instances
  instance AutoRoute ActivitiesController
#+end_src
#+caption: Parse controller routes
#+begin_src haskell :noweb-ref Parse controller routes
  , parseRoute @ActivitiesController
#+end_src
#+caption: Import controller actions
#+begin_src haskell :noweb-ref Import controller actions
  import Web.Controller.Activities
#+end_src

** User accesses Liikuntakirja via browser
We'll have to set the =Action= that's triggered on loading =/=. This goes into the main =Web/Routes.hs= file.
#+caption: Set ActivitiesAction as front page
#+begin_src haskell :noweb-ref Set ActivitiesAction as front page
  startPage ActivitiesAction
#+end_src

=ActivitiesAction= will then query all activities from the database and check if there's a newest activity to show.
#+caption: Index Activities using IndexView
#+begin_src haskell :noweb-ref Index Activities using IndexView
  action ActivitiesAction = do
    activities <- query @Activity |> orderByDesc #startTime |> fetch
    healthInfo <- query @HealthInformation |> fetchOne
    (selectedActivity, laps, tps) <- queryActivityAndItsChildren (head activities)
    let newActivity = newRecord
        chartData = chartActivityData healthInfo (selectedActivity, laps, tps)
    render IndexView { .. }
#+end_src

=IndexView= is going to render the web page for user's browser. It is dependent on a couple of defaults, namely the layout elements universal to any page we will be rendering, =defaultLayout=.

#+caption: Web/View/Layout.hs
#+begin_src haskell :tangle liikuntakirja/Web/View/Layout.hs

  module Web.View.Layout (defaultLayout, Html) where

  import IHP.ViewPrelude
  import IHP.Environment
  import Generated.Types
  import IHP.Controller.RequestContext
  import Web.Types
  import Web.Routes
  import Application.Helper.View

  defaultLayout :: Html -> Html
  defaultLayout inner = [hsx|
  <<Default page layout>>
  |]

  -- The 'assetPath' function used below appends a `?v=SOME_VERSION` to the static assets in production
  -- This is useful to avoid users having old CSS and JS files in their browser cache once a new version is deployed
  -- See https://ihp.digitallyinduced.com/Guide/assets.html for more details

  stylesheets :: Html
  stylesheets = [hsx|
          <<CSS stylesheets>>
      |]

  scripts :: Html
  scripts = [hsx|
          <<JavaScript libraries>>
      |]

  devScripts :: Html
  devScripts = [hsx|
          <<Development scripts>>
      |]

  metaTags :: Html
  metaTags = [hsx|
      <<Meta tags>>
  |]
#+end_src

=defaultLayout= uses a set of JavaScript libraries
#+caption: JavaScript libraries
#+begin_src html :noweb-ref JavaScript libraries
  {when isDevelopment devScripts}
  <script src={assetPath "/vendor/jquery-3.6.0.slim.min.js"}></script>
  <script src={assetPath "/vendor/timeago.js"}></script>
  <script src={assetPath "/vendor/popper-2.11.6.min.js"}></script>
  <script src={assetPath "/vendor/bootstrap-5.2.1/bootstrap.min.js"}></script>
  <script src={assetPath "/vendor/flatpickr.js"}></script>
  <script src={assetPath "/vendor/morphdom-umd.min.js"}></script>
  <script src={assetPath "/vendor/turbolinks.js"}></script>
  <script src={assetPath "/vendor/turbolinksInstantClick.js"}></script>
  <script src={assetPath "/vendor/turbolinksMorphdom.js"}></script>
  <script src={assetPath "/helpers.js"}></script>
  <script src={assetPath "/ihp-auto-refresh.js"}></script>
  <script src={assetPath "/app.js"}></script>
  <<Import JavaScript libraries>>
#+end_src

and a set of CSS stylesheets. Liikuntakirja uses the straightforward if bland Bootstrap stylesheet.
#+caption: CSS stylesheets
#+begin_src html :noweb-ref CSS stylesheets
  <link rel="stylesheet" href={assetPath "/vendor/bootstrap-5.2.1/bootstrap.min.css"}/>
  <link rel="stylesheet" href={assetPath "/vendor/flatpickr.min.css"}/>
  <link rel="stylesheet" href={assetPath "/app.css"}/>
#+end_src

Some =<meta>= tags too, you know, for '90s SEO or something.
#+caption: Meta tags
#+begin_src html :noweb-ref Meta tags
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
  <meta property="og:title" content="App"/>
  <meta property="og:type" content="website"/>
  <meta property="og:url" content="TODO"/>
  <meta property="og:description" content="TODO"/>
  {autoRefreshMeta}
#+end_src

Finally the default HTML with views like =IndexView= embedded into =inner= element.
#+caption: Default page layout
#+begin_src html :noweb-ref Default page layout
  <!DOCTYPE html>
  <html lang="en">
      <head>
          {metaTags}

          {stylesheets}
          {scripts}

          <title>{pageTitleOrDefault "App"}</title>
      </head>
      <body>
          <div class="container mt-4">
              {renderFlashMessages}
              {inner}
          </div>
      </body>
  </html>
#+end_src

=IndexView= then shows the main interface with the found activity and also catalogues all activities. IHP uses JSX-like HSX syntax. HSX enables embedding Haskell bindings inside page layouts. Since HSX contents are not Haskell, they have been abstracted away into separate code blocks.
#+caption: Web/View/Activities/Index.hs
#+begin_src haskell :tangle liikuntakirja/Web/View/Activities/Index.hs
  module Web.View.Activities.Index where
  import Web.View.Prelude
  import Data.Time.Format (formatTime, defaultTimeLocale)

  data IndexView = IndexView { activities :: [Activity]
                             , selectedActivity :: Maybe Activity
                             , chartData :: Maybe ChartData
                             , newActivity :: Activity
                             }

  instance View IndexView where
      html IndexView { .. } = [hsx|
          <<Lay out the unified interface>>
      |]

  renderSelectedActivity :: Maybe Activity -> Maybe ChartData -> Html
  renderSelectedActivity Nothing _ = [hsx|
                                       |]
  renderSelectedActivity (Just activity) (Just chartData) = [hsx|
           <<Lay out selected activity>>
                                               |]

  renderActivity :: Activity -> Html
  renderActivity activity = [hsx|
      <<Lay out the individual Activity for indexing>>
  |]

  renderHeadline :: Maybe Activity -> Html
  renderHeadline Nothing = [hsx|
                                   |]
  renderHeadline (Just activity) = [hsx|
      <<Lay out Activity headline>>
  |]

  renderForm :: Activity -> Html
  renderForm activity = formFor activity [hsx|
      <<Lay out Activity upload form>>
  |]

  navBar :: Html
  navBar = [hsx|
      <<Lay out navigation bar>>
      |]
    where
      links = renderBreadcrumb
        [ breadcrumbLink "Settings" EditHealthInformationAction
        ]
#+end_src

The unified interface is laid out using simple HTML and Bootstrap CSS classes.
#+caption: Lay out the unified interface
#+begin_src html :noweb-ref Lay out the unified interface
  {navBar}
  {renderHeadline selectedActivity}
  <div class="table">
    <table class="table">
      <tr>
        <td>{renderSelectedActivity selectedActivity chartData}</td>
        <td>
          <table class="table">
            <thead>
              <tr>
                <th colspan="2">{renderForm newActivity}</th>
              </tr>
            </thead>
            <tbody>{forEach activities renderActivity}</tbody>
          </table>
        </td>
      </tr>
    </table>
  </div>
#+end_src
#+caption: Lay out the individual Activity for indexing
#+begin_src html :noweb-ref Lay out the individual Activity for indexing
  <tr>
    <td><a href={ShowActivityAction activity.id} style="display:block;text-decoration:none;">{formatTime defaultTimeLocale "%a %b %e" (activity.startTime)}</a></td>
    <td><a href={DeleteActivityAction activity.id} class="js-delete text-muted">Delete</a></td>
  </tr>
#+end_src

#+caption: Lay out Activity headline
#+begin_src html :noweb-ref Lay out Activity headline
  <h1>Showing a {activity.planType} from {activity.startTime}</h1>
#+end_src

#+caption: Lay out navigation bar
#+begin_src html :noweb-ref Lay out navigation bar
  {links}
#+end_src

The unified interface can then be seen when loading =/Activities=
#+begin_src sh :results file graphics :file "./visualizations/activities_visualization.png" :dir .
  <<Chromium binary>> <<Chromium options>> "http://localhost:8000/Activities"
  <<Post-process screenshot>> visualizations/activities_visualization.png
#+end_src

** User edits their personal health information
User wants to input age for physical stress analysis. For now, it is left to the user to adjust this when looking at older activities. In a future version, user could put in their birthday and each activity will be adjusted for it in respect to activity time.

#+caption: UI mockup
[[./assets/editview.png]]

*** Propositions
We'll make a dedicated tests file for handling personal health information. We'll call the base model for this information =HealthInformation=.
#+caption: Test/Controller/HealthInformationsSpec.hs
#+begin_src haskell :tangle liikuntakirja/Test/Controller/HealthInformationsSpec.hs
  module Test.Controller.HealthInformationsSpec where

  <<Import universal IHP unit testing libraries>>

  import Web.Routes
  import Web.Types
  import Web.Controller.HealthInformations ()
  import Web.FrontController ()
  import Network.Wai
  import IHP.ControllerPrelude

  import Data.Text (unpack)

  tests :: Spec
  tests =
    aroundAll (withIHPApp WebApplication config) do
    describe "HealthInformationsController" $ do
      it "should start with one row" $ withContext do
        insertDefaultHealthInformation
        count <- query @HealthInformation |> fetchCount
        count `shouldBe` 1
    <<Call HealthInformation unit tests>>
    describe "HealthInformationsController" $ do
      it "should finish with one row" $ withContext do
        count <- query @HealthInformation |> fetchCount
        count `shouldBe` 1

  insertDefaultHealthInformation :: (?modelContext :: ModelContext) => IO HealthInformation
  insertDefaultHealthInformation = do
    newRecord @HealthInformation
    |> set #age defaultAge
    |> createRecord

  defaultAge = <<Default user age>> :: Int

  <<Test HealthInformation model>>

  <<Test HealthInformationsController>>
#+end_src

First off, we need to model user's personal health information, namely age. User is not interested in calories burned or other weight/height-related information. There will ever only be one row in the table that is always inserted when setting up database. Program cannot run without the row.
#+caption: Test HealthInformation model
#+begin_src haskell :noweb-ref Test HealthInformation model
  -- testModel :: Spec
  testModel = do
    describe "HealthInformations" $ do
      it "models age" $ withContext do
        health <- query @HealthInformation |> fetchOne
        health.age `shouldSatisfy` (\x -> x >= 0 && x <= 120)

#+end_src
#+caption: Call HealthInformation unit tests
#+begin_src haskell :noweb-ref Call HealthInformation unit tests
  testModel
#+end_src

The other thing we need is an Edit action which shows an editing view, and an Update action that updates database. We'll also have to agree on a default age for the user.
#+caption: Test HealthInformationsController
#+begin_src haskell :noweb-ref Test HealthInformationsController
  -- testController :: Spec
  testController = do
    describe "HealthInformationsController" $ do
      it "calling EditHealthInformationAction renders an editing form" $ withContext do
        mockActionStatus EditHealthInformationAction `shouldReturn` status200
      it "calling UpdateHealthInformationAction updates HealthInformation" $ withContext do
        health <- query @HealthInformation |> fetchOne
        health.age `shouldBe` defaultAge
        callActionWithParams UpdateHealthInformationAction [("age", fromString . unpack . show $ defaultAge + 20)]
        updatedHealth <- query @HealthInformation |> fetchOne
        updatedHealth.age `shouldBe` (defaultAge + 20)
#+end_src
#+caption: Call HealthInformation unit tests
#+begin_src haskell :noweb-ref Call HealthInformation unit tests
  testController
#+end_src

#+caption: Default user age
#+begin_src haskell :noweb-ref Default user age
  30
#+end_src

Lastly, we'll add this module to the main unit testing module
#+caption: Unit test modules
#+begin_src haskell :noweb-ref Unit test modules
  import Test.Controller.HealthInformationsSpec
#+end_src
#+caption: Unit test modules
#+begin_src haskell :noweb-ref Unit test module functions
  Test.Controller.HealthInformationsSpec.tests
#+end_src

*** Implementation
Let's set up our model first. We need a very simple table with only one column, and an INSERT statement into the fixtures file. Technically we don't need =id=, but the IHP architecture expects it (and maybe we'll have e.g. multiple users in the future).
#+caption: HealthInformation schema
#+begin_src sql :noweb-ref HealthInformation schema
  CREATE TABLE health_informations (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      age INT NOT NULL
  );
#+end_src
#+caption: Insert default HealthInformation row
#+begin_src sql :noweb-ref Insert default HealthInformation row
  INSERT INTO health_informations (age) VALUES (<<Default user age>>);
#+end_src

With the model set, we'll set up the controller.
#+caption: Web/Controller/HealthInformations.hs
#+begin_src haskell :tangle liikuntakirja/Web/Controller/HealthInformations.hs
  module Web.Controller.HealthInformations where

  import Web.Controller.Prelude
  import Web.View.HealthInformations.Edit

  instance Controller HealthInformationsController where
    action EditHealthInformationAction = do
          healthInformation <- query @HealthInformation |> fetchOne
          render EditView { .. }

    action UpdateHealthInformationAction = do
          healthInformation <- query @HealthInformation |> fetchOne
          healthInformation
              |> fill @'["age"]
              |> ifValid \case
                  Left healthInformation -> render EditView { .. }
                  Right healthInformation -> do
                      healthInformation <- healthInformation |> updateRecord
                      setSuccessMessage "Health information updated"
                      redirectTo ActivitiesAction
#+end_src

#+caption: Type HealthInformationController
#+begin_src haskell :noweb-ref Type HealthInformationController
  data HealthInformationsController
      = EditHealthInformationAction
      | UpdateHealthInformationAction -- { healthInformationId :: !(Id HealthInformation) }
      deriving (Eq, Show, Data)
#+end_src

#+caption: Controller routing instances
#+begin_src haskell :noweb-ref Controller routing instances
  instance AutoRoute HealthInformationsController
#+end_src
#+caption: Import controller actions
#+begin_src haskell :noweb-ref Import controller actions
  import Web.Controller.HealthInformations
#+end_src
#+caption: Parse controller routes
#+begin_src haskell :noweb-ref Parse controller routes
  , parseRoute @HealthInformationsController
#+end_src

And finally the =EditView= the controller makes for manipulating the model.
#+caption: Web/View/HealthInformations/Edit.hs
#+begin_src haskell :tangle liikuntakirja/Web/View/HealthInformations/Edit.hs
  module Web.View.HealthInformations.Edit where
  import Web.View.Prelude

  data EditView = EditView { healthInformation :: HealthInformation }

  instance View EditView where
      html EditView { .. } = [hsx|
                                 <<Lay out health information editing view>>
      |]
          where
              breadcrumb = renderBreadcrumb
                  [ breadcrumbLink "Back to activities" ActivitiesAction
                  , breadcrumbText "Edit age"
                  ]

  renderForm :: HealthInformation -> Html
  renderForm healthInformation = formFor healthInformation [hsx|
                                 <<Lay out health information editing form>>
  |]
#+end_src

#+caption: Lay out health information editing view
#+begin_src html :noweb-ref Lay out health information editing view
  {breadcrumb}
  <h1>Edit age</h1>
  {renderForm healthInformation}
#+end_src

#+caption: Lay out health information editing form
#+begin_src html :noweb-ref Lay out health information editing form
  {textField #age}
  {submitButton}
#+end_src

All HSpec tests should now be good:
#+begin_src haskell
  :l Test/Main
  hspec $ Test.Controller.HealthInformationsSpec.tests
#+end_src

The settings interface should look like the mockup in the user story:
#+begin_src sh :results file graphics :file "./visualizations/editsettings_visualization.png" :dir .
  <<Chromium binary>> <<Chromium options>> "http://localhost:8000/EditHealthInformation"
  <<Post-process screenshot>> visualizations/editsettings_visualization.png
#+end_src


** User uploads smartwatch data into Liikuntakirja
The user has TCX-formatted smartwatch data files on their computer, ready for uploading.
*** Propositions

Since parsing TCX files can be used in other programs too, we make it into a separate module with its own unit test suite.
#+caption: Test/Application/TCXSpec.hs
#+begin_src haskell :tangle liikuntakirja/Test/Application/TCXSpec.hs
  module Test.Application.TCXSpec where
  import Test.Hspec
  import IHP.Prelude
  import Data.Time (UTCTime)
  import Data.Text.IO (readFile)
  import Text.Read (read)

  import Application.TCX
  import Web.Types

  tests :: Spec
  tests = do
    <<TCX unit test calls>>

  <<TCX to record unit test>>
#+end_src
#+caption: Unit test module functions
#+begin_src haskell :noweb-ref Unit test module functions
  Test.Application.TCXSpec.tests
#+end_src

We will have to parse the XML into a Haskell record form. As XML and Haskell records are structurally similar, while the database model has children pointing to parents instead of parents pointing to children, we're using an intermediate record type. The intermediate record also eases modularization and thus use of the parser in other contexts.

Since the XML files and resulting records are big and not trivially referenced in string form in Haskell, we'll load them from respective files. We're happy with comparing both workout examples against a predefined =Show= instance results which too have been saved to separate files.
#+caption: TCX to record unit test
#+begin_src haskell :noweb-ref TCX to record unit test
  tcxToRecord :: Spec
  tcxToRecord = do
    describe "processTcxFile" $ do
      it "can parse and read TCX file into intermediate record" $ do
        convertedWalkingTcx <- processTcxFile "Test/test.walking.tcx"
        resultWalkingTcx <- readFile "Test/test.walking.tcx.result"
        (show convertedWalkingTcx ++ "\n") `shouldBe`
          resultWalkingTcx
        convertedStrengthTcx <- processTcxFile "Test/test.strength.tcx"
        resultStrengthTcx <- readFile "Test/test.strength.tcx.result"
        (show convertedStrengthTcx ++ "\n") `shouldBe`
          resultStrengthTcx
#+end_src
#+caption: TCX unit test calls
#+begin_src haskell :noweb-ref TCX unit test calls
  tcxToRecord
#+end_src

In the second step we will map and insert the intermediate record into the database by  "inverting" the XML/record rose tree. This happens in =ActivitiesController=.
#+caption: Test inserting a record provided by Application.TCX into database
#+begin_src haskell :noweb-ref Test inserting a record provided by Application.TCX into database
  testTcxUpload = do
    describe "ActivitiesController" $ do
      it "adds a TCX upload successfully into database" $ withContext do
        tcx <- fromJust . head <$> processTcxFile "Test/test.strength.tcx"
        insertTcxActivity tcx
        actCount <- query @Activity |> fetchCount
        actCount `shouldBe` 1
        lapCount <- query @Lap |> fetchCount
        actCount `shouldBe` 1
        tpCount <- query @Trackpoint |> fetchCount
        tpCount `shouldBe` 5
#+end_src
#+caption: ActivitiesSpec test function calls
#+begin_src haskell :noweb-ref ActivitiesSpec test function calls
  testTcxUpload
#+end_src

*** Implementation
To allow user uploads to =static/= directory, we'll have to import a configuration and some flags in =Config.hs= defined at Configure IHP
#+caption: Import upload configuration
#+begin_src haskell :noweb-ref Import upload configuration
  import IHP.FileStorage.Config
#+end_src
#+caption: Allow uploads
#+begin_src haskell :noweb-ref Allow uploads
  initStaticDirStorage
#+end_src

A simple file upload form is enough, everything in =Activity= can be derived from the uploaded TCX file.
#+caption: Lay out Activity upload form
#+begin_src html :noweb-ref Lay out Activity upload form
  {(fileField #uploadUrl) { required = True }}
  {submitButton}
#+end_src

Once the user has browsed for a file and clicks "Upload", we will pass the uploaded TCX for conversion. The file arrives at the  =CreateActivityAction=. User will be redirected back to the front page after the file has been processed server-side. The TCX file is converted into an intermediate =TcxActivity= and finally to an =Activity= compatible with our model. An intermediate form is used as it is easier to parse XML into a rose tree-like record than a database-style inverted tree.
#+caption: Create Activity from uploaded TCX
#+begin_src haskell :noweb-ref Create Activity from uploaded TCX
  action CreateActivityAction = do
    <<Convert uploaded TCX into TcxActivity>>
    activityId <- (\x -> x.id) <$> insertTcxActivity tcx
    setSuccessMessage ("Activity uploaded!")
    redirectTo $ ShowActivityAction { .. }
#+end_src

The TCX file we've received is an XML-formatted file. In the file, Trackpoints are of most interest as it keeps track of heart rate, speed and time, but Lap and Activity have some useful metadata too. We have to expect that occasionally any other field than =Time= can be missing, as even heart rate might not be included in first couple Trackpoint nodes. An example TCX produced by a 5-second strength training workout.
#+caption: Test/test.strength.tcx
#+begin_src xml :tangle liikuntakirja/Test/test.strength.tcx
<?xml version="1.0" encoding="UTF-8"?>
<TrainingCenterDatabase xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2">
  <Activities>
    <Activity Sport="Other">
      <Id>2024-03-19T12:28:24.470Z</Id>
      <Lap StartTime="2024-03-19T12:28:25.470Z">
        <TotalTimeSeconds>5.0</TotalTimeSeconds>
        <DistanceMeters>0.0</DistanceMeters>
        <Calories>1</Calories>
        <AverageHeartRateBpm>
          <Value>61</Value>
        </AverageHeartRateBpm>
        <MaximumHeartRateBpm>
          <Value>61</Value>
        </MaximumHeartRateBpm>
        <Intensity>Active</Intensity>
        <TriggerMethod>Manual</TriggerMethod>
        <Track>
          <Trackpoint>
            <Time>2024-03-19T12:28:25.470Z</Time>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:26.470Z</Time>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:27.470Z</Time>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:28.470Z</Time>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
          <Trackpoint>
            <Time>2024-03-19T12:28:29.470Z</Time>
            <HeartRateBpm>
              <Value>61</Value>
            </HeartRateBpm>
            <SensorState>Present</SensorState>
          </Trackpoint>
        </Track>
      </Lap>
      <Training VirtualPartner="false">
        <Plan Type="Workout" IntervalWorkout="false">
          <Extensions/>
        </Plan>
      </Training>
      <Creator xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Device_t">
        <Name>Polar INW3N_V2</Name>
        <UnitId>0</UnitId>
        <ProductID>0</ProductID>
        <Version>
          <VersionMajor>0</VersionMajor>
          <VersionMinor>0</VersionMinor>
          <BuildMajor>0</BuildMajor>
          <BuildMinor>0</BuildMinor>
        </Version>
      </Creator>
    </Activity>
  </Activities>
  <Author xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Application_t">
    <Name>https://github.com/cmaion/polar</Name>
    <Build>
      <Version>
        <VersionMajor>0</VersionMajor>
        <VersionMinor>0</VersionMinor>
      </Version>
    </Build>
    <LangID>EN</LangID>
    <PartNumber>XXX-XXXXX-XX</PartNumber>
  </Author>
</TrainingCenterDatabase>
#+end_src

Another truncated example of a walking workout. Note that sport is "Other" regardless if it is strength training (previous case) or walking (this case). Superfluous and identical with previous case, Author and Creator parts were cut out in this case to save your eyes. In the walking workout there is a peculiar edge case: as the watch auto-laps every 1000.0m, the last Lap will both lack some fields like heart rate statistics and have zero calories and cadence. As with previous case and this case, the XML's have been cut out from larger XML files and are not 100% authentic and shouldn't be taken as complete gospel.
#+caption: Test/test.walking.tcx
#+begin_src xml :tangle liikuntakirja/Test/test.walking.tcx
  <?xml version="1.0" encoding="UTF-8"?>
  <TrainingCenterDatabase xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2">
    <Activities>
      <Activity Sport="Other">
        <Id>2024-03-28T11:03:14.101Z</Id>
        <Lap StartTime="2024-03-28T11:03:15.101Z">
          <TotalTimeSeconds>2.0</TotalTimeSeconds>
          <DistanceMeters>3.7</DistanceMeters>
          <MaximumSpeed>1.8311089939541287</MaximumSpeed>
          <Calories>3</Calories>
          <AverageHeartRateBpm>
            <Value>73</Value>
          </AverageHeartRateBpm>
          <MaximumHeartRateBpm>
            <Value>73</Value>
          </MaximumHeartRateBpm>
          <Intensity>Active</Intensity>
          <Cadence>51</Cadence>
          <TriggerMethod>Distance</TriggerMethod>
          <Track>
            <Trackpoint>
              <Time>2024-03-28T11:03:15.101Z</Time>
              <Position>
                <LatitudeDegrees>61.44253</LatitudeDegrees>
                <LongitudeDegrees>23.85222667</LongitudeDegrees>
              </Position>
              <AltitudeMeters>158.193</AltitudeMeters>
              <DistanceMeters>0.0</DistanceMeters>
              <HeartRateBpm>
                <Value>73</Value>
              </HeartRateBpm>
              <Cadence>0</Cadence>
              <SensorState>Present</SensorState>
            </Trackpoint>
            <Trackpoint>
              <Time>2024-03-28T11:03:16.101Z</Time>
              <Position>
                <LatitudeDegrees>61.44255</LatitudeDegrees>
                <LongitudeDegrees>23.85222</LongitudeDegrees>
              </Position>
              <AltitudeMeters>158.193</AltitudeMeters>
              <DistanceMeters>0.0</DistanceMeters>
              <HeartRateBpm>
                <Value>73</Value>
              </HeartRateBpm>
              <Cadence>0</Cadence>
              <SensorState>Present</SensorState>
            </Trackpoint>
            <Trackpoint>
              <Time>2024-03-28T11:03:17.101Z</Time>
              <Position>
                <LatitudeDegrees>61.44256333</LatitudeDegrees>
                <LongitudeDegrees>23.85222833</LongitudeDegrees>
              </Position>
              <AltitudeMeters>158.193</AltitudeMeters>
              <DistanceMeters>0.0</DistanceMeters>
              <HeartRateBpm>
                <Value>73</Value>
              </HeartRateBpm>
              <Cadence>0</Cadence>
              <SensorState>Present</SensorState>
            </Trackpoint>
          </Track>
        </Lap>
        <Lap StartTime="2024-03-28T11:52:28.854Z">
          <TotalTimeSeconds>2.58500000000004</TotalTimeSeconds>
          <DistanceMeters>3.439990234375</DistanceMeters>
          <Calories>0</Calories>
          <Intensity>Active</Intensity>
          <TriggerMethod>Distance</TriggerMethod>
          <Track>
            <Trackpoint>
              <Time>2024-03-28T11:52:28.854Z</Time>
              <AltitudeMeters>161.089</AltitudeMeters>
              <DistanceMeters>3003.800048828125</DistanceMeters>
              <HeartRateBpm>
                <Value>106</Value>
              </HeartRateBpm>
              <Cadence>55</Cadence>
              <SensorState>Present</SensorState>
            </Trackpoint>
            <Trackpoint>
              <Time>2024-03-28T11:52:29.854Z</Time>
              <AltitudeMeters>161.089</AltitudeMeters>
              <DistanceMeters>3005.10009765625</DistanceMeters>
              <HeartRateBpm>
                <Value>107</Value>
              </HeartRateBpm>
              <Cadence>55</Cadence>
              <SensorState>Present</SensorState>
            </Trackpoint>
          </Track>
        </Lap>
        <Training VirtualPartner="false">
          <Plan Type="Workout" IntervalWorkout="false">
            <Extensions/>
          </Plan>
        </Training>
        <Creator xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="Device_t">
          <Name>Polar INW3N_V2</Name>
        </Creator>
      </Activity>
    </Activities>
  </TrainingCenterDatabase>
#+end_src

The following type structures are directly derived from thes two XML structures with uninteresting data pruned out. We end up with a tree structure going from Activity, to Lap, to Trackpoint. Intermediate types are prefixed by 'Tcx' to avoid collisions with IHP's database-derived types. =Activity='s intermediate type:
#+caption: TcxActivity
#+begin_src haskell :noweb-ref TcxActivity
  data TcxActivity = TcxActivity
    { tcxLaps :: [TcxLap]
    , tcxSport :: Text
    , tcxActStart :: UTCTime
    , tcxPlanType :: Text
    , tcxDeviceName :: Text
    } deriving (Eq, Show)
#+end_src
And the database schema for =Activity= derived from it:
#+caption: Activity schema
#+begin_src sql :noweb-ref Activity schema
  CREATE TABLE activities (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      sport TEXT NOT NULL,
      start_time TIMESTAMP WITH TIME ZONE NOT NULL,
      plan_type TEXT NOT NULL,
      device_name TEXT NOT NULL,
      upload_url TEXT NOT NULL
  );
#+end_src

=Activities= consist of one or more =Laps=.
#+caption: TcxLap
#+begin_src haskell :noweb-ref TcxLap
  data TcxLap = TcxLap
    { tcxTrack :: TcxTrack
    , tcxLapStart :: UTCTime
    , tcxLapTotal :: TotalTimeSec
    , tcxLapDistance :: DistanceMeters
    , tcxMaxSpeed :: Maybe Float
    , tcxCals :: Calories
    , tcxAvgHR :: Maybe HeartRateBpm
    , tcxMaxHR :: Maybe HeartRateBpm
    , tcxIntensity :: Text
    , tcxLapCadence :: Maybe Int
    , tcxTrigger :: Text
    } deriving (Eq, Show)
#+end_src
#+caption: Lap schema
#+begin_src sql :noweb-ref Lap schema
  CREATE TABLE laps (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      activity_id UUID NOT NULL,
      start_time TIMESTAMP WITH TIME ZONE NOT NULL,
      total_time REAL NOT NULL,
      distance REAL NOT NULL,
      maximum_speed REAL DEFAULT NULL,
      calories INT NOT NULL,
      average_hr INT DEFAULT NULL,
      maximum_hr INT DEFAULT NULL,
      intensity TEXT NOT NULL,
      cadence INT DEFAULT NULL,
      "trigger" TEXT NOT NULL
  );
#+end_src

=Laps= in turn consist of tracks which are collections of =Trackpoints=. We will assume any extra tracks can be concatenated into one single track to simplify the data model.
#+caption: TcxTrackpoint
#+begin_src haskell :noweb-ref TcxTrackpoint
  data TcxTrackpoint = TcxTrackpoint
    { tcxTpTime :: UTCTime
    , tcxLatitude :: Maybe Float
    , tcxLongitude :: Maybe Float
    , tcxAltitude :: Maybe DistanceMeters
    , tcxTpDistance :: Maybe DistanceMeters
    , tcxTpHR :: Maybe HeartRateBpm
    , tcxCadence :: Maybe Int
    , tcxSensor :: Text
    } deriving (Eq, Show)

  type TcxTrack = [TcxTrackpoint]
#+end_src
#+caption: Trackpoint schema
#+begin_src sql :noweb-ref Trackpoint schema
  CREATE TABLE trackpoints (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY NOT NULL,
      lap_id UUID NOT NULL,
      point_time TIMESTAMP WITH TIME ZONE NOT NULL,
      latitude REAL DEFAULT NULL,
      longitude REAL DEFAULT NULL,
      altitude REAL DEFAULT NULL,
      point_distance REAL DEFAULT NULL,
      hr INT DEFAULT NULL,
      cadence INT DEFAULT NULL,
      sensor TEXT NOT NULL
  );
#+end_src

We collect these along with some descriptive aliases into types for the application.
#+caption: Tcx types
#+begin_src haskell :noweb-ref Tcx types
  type TotalTimeSec = Float
  type DistanceMeters = Float
  type Calories = Int
  type HeartRateBpm = Int

  <<TcxTrackpoint>>

  <<TcxLap>>

  <<TcxActivity>>
#+end_src
#+caption: Tcx schema
#+begin_src sql :noweb-ref Tcx schema
  <<Activity schema>>
  <<Lap schema>>
  <<Trackpoint schema>>
#+end_src

With these types, the strength training TCX file should then parse into a structure like this.
#+caption: Truncated strength training TCX XML parsed into a record
#+begin_src haskell
  [ TcxActivity
    { tcxLaps =
      [ TcxLap
        { tcxTrack =
          [ TcxTrackpoint
            { tcxTpTime = 2024-03-19 12:28:25.47 UTC
            , tcxLatitude = Nothing
            , tcxLongitude = Nothing
            , tcxAltitude = Nothing
            , tcxTpDistance = Nothing
            , tcxTpHR = Nothing
            , tcxCadence = Nothing
            , tcxSensor = "Present"
            }
          , TcxTrackpoint
            { tcxTpTime = 2024-03-19 12:28:26.47 UTC
            , tcxLatitude = Nothing
            , tcxLongitude = Nothing
            , tcxAltitude = Nothing
            , tcxTpDistance = Nothing
            , tcxTpHR = Nothing
            , tcxCadence = Nothing
            , tcxSensor = "Present"
            }
          , TcxTrackpoint
            { tcxTpTime = 2024-03-19 12:28:27.47 UTC
            , tcxLatitude = Nothing
            , tcxLongitude = Nothing
            , tcxAltitude = Nothing
            , tcxTpDistance = Nothing
            , tcxTpHR = Just 61
            , tcxCadence = Nothing
            , tcxSensor = "Present"
            }
          , TcxTrackpoint
            { tcxTpTime = 2024-03-19 12:28:28.47 UTC
            , tcxLatitude = Nothing
            , tcxLongitude = Nothing
            , tcxAltitude = Nothing
            , tcxTpDistance = Nothing
            , tcxTpHR = Just 61
            , tcxCadence = Nothing
            , tcxSensor = "Present"
            }
          , TcxTrackpoint
            { tcxTpTime = 2024-03-19 12:28:29.47 UTC
            , tcxLatitude = Nothing
            , tcxLongitude = Nothing
            , tcxAltitude = Nothing
            , tcxTpDistance = Nothing
            , tcxTpHR = Just 61
            , tcxCadence = Nothing
            , tcxSensor = "Present"
            }
          ]
        , tcxLapStart = 2024-03-19 12:28:25.47 UTC
        , tcxLapTotal = 5.0
        , tcxLapDistance = 0.0
        , tcxMaxSpeed = Nothing
        , tcxCals = 1
        , tcxAvgHR = Just 61
        , tcxMaxHR = Just 61
        , tcxIntensity = "Active"
        , tcxLapCadence = Nothing
        , tcxTrigger = "Manual"
        }
      ]
    , tcxSport = "Other"
    , tcxActStart = 2024-03-19 12:28:24.47 UTC
    , tcxPlanType = "Workout"
    , tcxDeviceName = "Polar INW3N_V2"
    }
  ]
#+end_src

=TcxActivity='s =Show= instance would then produce this for comparison test:
#+caption: Test/test.strength.tcx.result
#+begin_src haskell :tangle liikuntakirja/Test/test.strength.tcx.result
  [TcxActivity {tcxLaps = [TcxLap {tcxTrack = [TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:25.47 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Nothing, tcxTpDistance = Nothing, tcxTpHR = Nothing, tcxCadence = Nothing, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:26.47 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Nothing, tcxTpDistance = Nothing, tcxTpHR = Nothing, tcxCadence = Nothing, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:27.47 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Nothing, tcxTpDistance = Nothing, tcxTpHR = Just 61, tcxCadence = Nothing, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:28.47 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Nothing, tcxTpDistance = Nothing, tcxTpHR = Just 61, tcxCadence = Nothing, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-19 12:28:29.47 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Nothing, tcxTpDistance = Nothing, tcxTpHR = Just 61, tcxCadence = Nothing, tcxSensor = "Present"}], tcxLapStart = 2024-03-19 12:28:25.47 UTC, tcxLapTotal = 5.0, tcxLapDistance = 0.0, tcxMaxSpeed = Nothing, tcxCals = 1, tcxAvgHR = Just 61, tcxMaxHR = Just 61, tcxIntensity = "Active", tcxLapCadence = Nothing, tcxTrigger = "Manual"}], tcxSport = "Other", tcxActStart = 2024-03-19 12:28:24.47 UTC, tcxPlanType = "Workout", tcxDeviceName = "Polar INW3N_V2"}]
#+end_src
Similarly, the walking workout should then produce this.
#+caption: Test/test.walking.tcx.result
#+begin_src haskell :tangle liikuntakirja/Test/test.walking.tcx.result
  [TcxActivity {tcxLaps = [TcxLap {tcxTrack = [TcxTrackpoint {tcxTpTime = 2024-03-28 11:03:15.101 UTC, tcxLatitude = Just 61.44253, tcxLongitude = Just 23.852226, tcxAltitude = Just 158.193, tcxTpDistance = Just 0.0, tcxTpHR = Just 73, tcxCadence = Just 0, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-28 11:03:16.101 UTC, tcxLatitude = Just 61.44255, tcxLongitude = Just 23.85222, tcxAltitude = Just 158.193, tcxTpDistance = Just 0.0, tcxTpHR = Just 73, tcxCadence = Just 0, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-28 11:03:17.101 UTC, tcxLatitude = Just 61.442562, tcxLongitude = Just 23.852228, tcxAltitude = Just 158.193, tcxTpDistance = Just 0.0, tcxTpHR = Just 73, tcxCadence = Just 0, tcxSensor = "Present"}], tcxLapStart = 2024-03-28 11:03:15.101 UTC, tcxLapTotal = 2.0, tcxLapDistance = 3.7, tcxMaxSpeed = Just 1.831109, tcxCals = 3, tcxAvgHR = Just 73, tcxMaxHR = Just 73, tcxIntensity = "Active", tcxLapCadence = Just 51, tcxTrigger = "Distance"},TcxLap {tcxTrack = [TcxTrackpoint {tcxTpTime = 2024-03-28 11:52:28.854 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Just 161.089, tcxTpDistance = Just 3003.8, tcxTpHR = Just 106, tcxCadence = Just 55, tcxSensor = "Present"},TcxTrackpoint {tcxTpTime = 2024-03-28 11:52:29.854 UTC, tcxLatitude = Nothing, tcxLongitude = Nothing, tcxAltitude = Just 161.089, tcxTpDistance = Just 3005.1, tcxTpHR = Just 107, tcxCadence = Just 55, tcxSensor = "Present"}], tcxLapStart = 2024-03-28 11:52:28.854 UTC, tcxLapTotal = 2.585, tcxLapDistance = 3.4399903, tcxMaxSpeed = Nothing, tcxCals = 0, tcxAvgHR = Nothing, tcxMaxHR = Nothing, tcxIntensity = "Active", tcxLapCadence = Nothing, tcxTrigger = "Distance"}], tcxSport = "Other", tcxActStart = 2024-03-28 11:03:14.101 UTC, tcxPlanType = "Workout", tcxDeviceName = "Polar INW3N_V2"}]
#+end_src

First we'll convert the uploaded XML into the =TcxActivity= record type. TCX files can theoretically have multiple =Activities=, but they are not expected in this case. Neither is graceful exception handling required due to threaded nature of IHP and the singular purpose of the upload request, so using =fromJust= as a shortcut is fine for now.
#+caption: Convert uploaded TCX into TcxActivity
#+begin_src haskell :noweb-ref Convert uploaded TCX into TcxActivity
  let tcx :: TcxActivity =
        fileOrNothing "uploadUrl"
        |> fromMaybe (error "no file given")
        |> (.fileContent)
        |> cs
        |> processTcxUpload
        |> head
        |> fromJust
#+end_src

The external functions used in these conversions. Using =fromJust= is fine in cases where we can expect XML to be correctly formed and in malformed cases the silent =error= is not an issue. The service will keep on running in these cases.
#+caption: Import TCX conversion functions
#+begin_src haskell :noweb-ref Import TCX conversion functions
  import Application.TCX (processTcxUpload)
  import Data.Maybe (fromJust)
#+end_src

Since there are no libraries available for directly extracting the TCX format, we'll construct a filter chain using =xml-conduit= (Text.XML and Text.XML.Cursor).
#+caption: Haskell dependencies
#+begin_src nix :noweb-ref Haskell dependencies
xml-conduit
#+end_src
#+caption: Application/TCX.hs
#+begin_src haskell :tangle liikuntakirja/Application/TCX.hs
  {-# LANGUAGE OverloadedStrings #-}

  module Application.TCX (processTcxFile, processTcxUpload) where

  import Data.Maybe (fromJust)
  import Data.Text (Text)
  import qualified Data.Text as T
  import qualified Data.Text.Lazy as TL
  import qualified Data.Text.Lazy.IO as TLIO
  import Data.Time (UTCTime)
  import Data.Time.Format.ISO8601 (formatParseM, iso8601Format)
  import Text.XML
  import Text.XML.Cursor

  import IHP.Prelude
  import Text.Read (readMaybe)
  import Web.Types

  <<Key TCX functions>>

  <<The TCX inner works>>
#+end_src

There are two entry points to this TCX extractor: =processTcxFile= and =processTcxUpload=. Either approach would be fine with IHP's file uploading routine, but converting from =Text= rather than from =FilePath= inside =IO= monad is more straightforward. XML extractors like /Haskell XML Toolkit/ only work with files, so having =processTcxFile= is fulfilling idiomatic expectations, but also enables testing with larger files.
#+caption: Key TCX functions
#+begin_src haskell :noweb-ref Key TCX functions
  processTcxFile :: FilePath -> IO [TcxActivity]
  processTcxFile file = processTcx <$> TLIO.readFile file

  processTcxUpload :: Text -> [TcxActivity]
  processTcxUpload = processTcx . TL.pack . T.unpack

  processTcx :: TL.Text -> [TcxActivity]
  processTcx = getActivities . fromDocument . parseText_ def
#+end_src

Extracting the fields in this case is logically simple if repetitive and verbose. It could be cleaned up with some helper functions. =read= is used, but as before, graceful exception handling is not required here, although could be relatively easily added since the return value of =[TcxActivity]= is essentially a =Maybe= structure.
#+caption: The TCX inner works
#+begin_src haskell :noweb-ref The TCX inner works
  getActivities :: Cursor -> [TcxActivity]
  getActivities cr =
    let activitiesCr = child cr >>= laxElement "Activities" >>= child >>= laxElement "Activity"
    in map getActivity activitiesCr

  getActivity :: Cursor -> TcxActivity
  getActivity cr =
    let lapsCr = child cr >>= laxElement "Lap"
        startTime = readTime . T.concat $ child cr >>= laxElement "Id" >>= descendant >>= content
    in TcxActivity
       (map getLap lapsCr)
       (T.concat $ attribute "Sport" cr)
       startTime
       (T.concat $ child cr >>= laxElement "Training" >>= child >>= laxElement "Plan" >>= attribute "Type")
       (T.concat $ child cr >>= laxElement "Creator" >>= child >>= laxElement "Name" >>= child >>= content)

  getLap :: Cursor -> TcxLap
  getLap cr =
    let tracksCr = child cr >>= laxElement "Track" >>= child >>= laxElement "Trackpoint"
    in TcxLap
       (map getTrackpoint tracksCr)
       (readTime . T.concat $ attribute "StartTime" cr)
            (fromJust . readContent $ child cr >>= laxElement "TotalTimeSeconds" >>= child >>= content)
       (fromJust . readContent $ child cr >>= laxElement "DistanceMeters" >>= child >>= content)
       (readContent $ child cr >>= laxElement "MaximumSpeed" >>= child >>= content)
       (fromJust . readContent $ child cr >>= laxElement "Calories" >>= child >>= content)
       (readContent $ child cr >>= laxElement "AverageHeartRateBpm" >>= child >>= laxElement "Value" >>= child >>= content)
       (readContent $ child cr >>= laxElement "MaximumHeartRateBpm" >>= child >>= laxElement "Value" >>= child >>= content)
       (T.concat $ child cr >>= laxElement "Intensity" >>= child >>= content)
       (readContent $ child cr >>= laxElement "Cadence" >>= child >>= content)
       (T.concat $ child cr >>= laxElement "TriggerMethod" >>= child >>= content)


  getTrackpoint :: Cursor -> TcxTrackpoint
  getTrackpoint cr =
    TcxTrackpoint
    (readTime . T.concat $ child cr >>= laxElement "Time" >>= child >>= content)
    (readContent $ child cr >>= laxElement "Position" >>= child >>= laxElement "LatitudeDegrees" >>= child >>= content)
    (readContent $ child cr >>= laxElement "Position" >>= child >>= laxElement "LongitudeDegrees" >>= child >>= content)
    (readContent $ child cr >>= laxElement "AltitudeMeters" >>= child >>= content)
    (readContent $ child cr >>= laxElement "DistanceMeters" >>= child >>= content)
    (readContent $ child cr >>= laxElement "HeartRateBpm" >>= child >>= laxElement "Value" >>= child >>= content)
    (readContent $ child cr >>= laxElement "Cadence" >>= child >>= content)
    (T.concat $ child cr >>= laxElement "SensorState" >>= child >>= content)


  readContent :: (Read a) => [Text] -> Maybe a
  readContent = readMaybe . T.unpack . T.concat

  readTime :: Text -> UTCTime
  readTime = fromJust . formatParseM iso8601Format . T.unpack
#+end_src

Having put all this together, we can now convert a TCX file into a Haskell record structure:
#+begin_src haskell
  :l Test/Main
  hspec $ Test.Application.TCXSpec.tcxToRecord
#+end_src

Then we can do a type conversion similar to the one we did in when reading the XML: converting from the intermediate =TcxActivity= into the =Activity=  and others, which are then saved in the database via =createRecord= and its merged INSERT variation =createMany=. IHP will then be using =Activity=, =Lap= and =Trackpoint= in the views.
#+caption: Convert TcxActivity into Activity and other database records
#+begin_src haskell :noweb-ref Convert TcxActivity into Activity and other database records
  insertTcxActivity :: (?modelContext::ModelContext) => TcxActivity -> IO Activity
  insertTcxActivity tcx = do
    activity <- newRecord @Activity
                |> set #sport (tcxSport tcx)
                |> set #startTime (tcxActStart tcx)
                |> set #planType (tcxPlanType tcx)
                |> set #deviceName (tcxDeviceName tcx)
                |> createRecord
    laps <- createMany $ map (\lap -> newRecord @Lap
                                      |> set #activityId (unpackId activity.id)
                                      |> set #startTime (tcxLapStart lap)
                                      |> set #totalTime (tcxLapTotal lap)
                                      |> set #distance (tcxLapDistance lap)
                                      |> set #maximumSpeed (tcxMaxSpeed lap)
                                      |> set #calories (tcxCals lap)
                                      |> set #averageHr (tcxAvgHR lap)
                                      |> set #maximumHr (tcxMaxHR lap)
                                      |> set #intensity (tcxIntensity lap)
                                      |> set #cadence (tcxLapCadence lap)
                                      |> set #trigger (tcxTrigger lap)
                             ) (tcxLaps tcx)
    let lapIdsWithTracks = zip (map (.id) laps) (map tcxTrack $ tcxLaps tcx)
    mapM_ (\(lapId, tcks) ->
             createMany $ map (\tck -> newRecord @Trackpoint
                                       |> set #lapId (unpackId lapId)
                                       |> set #pointTime (tcxTpTime tck)
                                       |> set #latitude (tcxLatitude tck)
                                       |> set #longitude (tcxLongitude tck)
                                       |> set #altitude (tcxAltitude tck)
                                       |> set #pointDistance (tcxTpDistance tck)
                                       |> set #hr (tcxTpHR tck)
                                       |> set #cadence (tcxCadence tck)
                                       |> set #sensor (tcxSensor tck)
                              ) tcks
          ) lapIdsWithTracks
    return activity
#+end_src

#+begin_src haskell :results value replace
  :l Test/Main
  hspec $ Test.Application.Spec.tcxToRecord
#+end_src

These two conversions then come together and with the results saved into database with =createRecord= and =createMany= earlier, we can congratulate the user and show them the uploaded =Activity=.

#+begin_src haskell :results value replace
  :l Test/Controller/ActivitiesSpec.hs
  hspec $ aroundAll (withIHPApp WebApplication config) $ Test.Controller.ActivitiesSpec.testTcxUpload
#+end_src
** User looks at an activity
User opens the main view and either the newest activity or one they selected pops into their view. Details about their heart rate, heart rate zones, speed, and cadence along with total distance moved come into their view. Each new lap should be indicated in the graph. The graphs and info can be seen in [[interface mock-up][the united interface mock-up]].
*** Propositions

In this part of the story, we'll have to consider how to visualize the data for the user, and how to get the data in a suitable form for proper visualization. We will use one chart for heart rate, its zones, speed and cadence, another smaller donut chart for visualizing the zones, and a small table for total distance, time, maybe calories and other tidbits in case the user suddenly comes up with new requirements

The charts and table should look like in [[interface mock-up][the united interface mock-up]].

To fetch and sculpt the required data properly, these tests should pass.
#+caption: Test/Controller/ActivitiesSpec.hs
#+begin_src haskell :tangle liikuntakirja/Test/Controller/ActivitiesSpec.hs
  testChartData = do
    describe "ActivitiesController" $ do
      it "fetches data" $ withContext do
        deleteAll @Activity
        (activity, laps, tps) <- query @Activity |> fetchOneOrNothing >>= queryActivityAndItsChildren
        (isJust activity) `shouldBe` False
        laps `shouldBe` []
        tps `shouldBe` [[]]
        createFauxActivity
        (justActivity, justLaps, justTps) <- query @Activity |> fetchOneOrNothing >>= queryActivityAndItsChildren
        (isJust justActivity) `shouldBe` True
        length justLaps `shouldBe` 1
        length (concat justTps) `shouldBe` 5
      it "sculpts the data as intended for charts" $ withContext do
        deleteAll @Activity
        createFauxActivity
        (activity, laps, tps) <- query @Activity |> fetchOneOrNothing >>= queryActivityAndItsChildren
        let hrSeries = map hr (concat tps)
        hrSeries `shouldBe` [Nothing, Nothing, Just 61, Just 61, Just 61]
        let avgHr = avgOver10s $ map (fromIntegral . fromMaybe 0) hrSeries
        avgHr `shouldBe` [36.6] -- Nothing is read as 0.0, we want to keep list length in line with time
      it "shows a selected activity" $ withContext do
        deleteAll @HealthInformation
        insertDefaultHealthInformation
        deleteAll @Activity
        createFauxActivity
        activity <- query @Activity |> fetchOne
        response <- callAction $ ShowActivityAction { activityId = activity.id }
        response `responseStatusShouldBe` status200
        response `responseBodyShouldContain` ("Showing a " ++ (activity.planType) ++ " from " ++ (show $ activity.startTime))
    where
      createFauxActivity :: (?modelContext::ModelContext) => IO Activity
      createFauxActivity =
        fromJust . head <$> processTcxFile "Test/test.strength.tcx" >>= insertTcxActivity
#+end_src
#+caption: ActivitiesSpec test function calls
#+begin_src haskell :noweb-ref ActivitiesSpec test function calls
  testChartData
#+end_src

*** Implementation
**** Plotting the activity
We'll be using an external =chart.js= library for plotting the data points. We'll amend =Web/View/Layout.hs= to include it.
#+caption: Import JavaScript libraries
#+begin_src html :noweb-ref Import JavaScript libraries
  <script src={assetPath "/chart.umd.min.js"}></script>
#+end_src

There are 5 different data types to chart over time. Ideally these would fit in a single chart. Heart rate and heart rate zones, speed and cadence, and laps are quite interrelated. We will get a set of labels (time), and matching datasets of the 5 data types. Let's start with the main plotting JavaScript script block. We'll fill in labels and dataset data later using another client-side block, we're now more concerned about how the data should be presented.
#+caption: Plot selected activity
#+begin_src js :noweb-ref Plot selected activity
  <script id="activityPlotter"
  data-heartrate={cdHeartRate chartData}
  data-heartratezone1={(\(x,a,b,c,d) -> x) (cdHeartRateZones chartData)}
  data-heartratezone2={(\(a,x,b,c,d) -> x) (cdHeartRateZones chartData)}
  data-heartratezone3={(\(a,b,x,c,d) -> x) (cdHeartRateZones chartData)}
  data-heartratezone4={(\(a,b,c,x,d) -> x) (cdHeartRateZones chartData)}
  data-heartratezone5={(\(a,b,c,d,x) -> x) (cdHeartRateZones chartData)}
  data-speed={cdSpeed chartData}
  data-cadence={cdCadence chartData}
  data-laps={cdLaps chartData}
  data-time={cdTime chartData}
  data-totaltime={cdTotalTime chartData}>
  var ctx = document.getElementById("activityChart").getContext('2d');
  var aPChart = new Chart(ctx, {
    data: {
      labels: [],
      datasets: [
          <<Plot heart rate>>
          ,
          <<Plot speed>>
          ,
          <<Plot cadence>>
          ,
          <<Plot laps>>
          ,
          <<Plot heart rate zones>>
          ]
        },
    options: {
      normalized: true,
      aspectRatio: 1,
      scales: {
        <<Scale heart rate>>
        ,
        <<Scale time>>
      },
      <<Filter out heart rate zone legends>>
    }
  });
  </script>
#+end_src

To plot and scale heart rates, following structures should do:
#+caption: Plot heart rate
#+begin_src js :noweb-ref Plot heart rate
  {
    type: 'line',
    label: 'Heart rate',
    data: [],
    fill: false,
    borderColor: 'rgb(192, 75, 75)',
    pointStyle: false,
    tension: 0.1,
    yAxisID: 'bpmY',
  }
#+end_src
To visualize the user's descent into old age, we'll always keep the maximum heart rate scale at the theoretical 20yo's maximum of 200 BPM. A common maximum is needed to visualize differences between exercises.
#+caption: Scale heart rate
#+begin_src js :noweb-ref Scale heart rate
  bpmY: {
    min: 0,
    max: 200,
    position: 'left',
    title: {
      display: true,
      text: 'BPM, RPM, Km/h',
    },
    grid: {
      color: 'rgb(255,255,255)'
    }
  }
#+end_src

The heart rate zones require a bit of a different approach. Ideally we would paint Y axis partitioned into zones with respective colors, but straight lines delineating the zones should do also. We need to make 5 distinct zones.
#+caption: Plot heart rate zones
#+begin_src js :noweb-ref Plot heart rate zones
  {
    type: 'line',
    label: '50% zone',
    data: [],
    fill: true,
    backgroundColor: 'rgba(128, 192, 255, 0.5)',
    pointStyle: false,
    tension: 0,
    yAxisID: 'bpmY',
    showLine: false
  },
  {
    type: 'line',
    label: '60% zone',
    data: [],
    fill: true,
    backgroundColor: 'rgba(192, 192, 255, 0.5)',
    pointStyle: false,
    tension: 0,
    yAxisID: 'bpmY',
    showLine: false
  },
  {
    type: 'line',
    label: '70% zone',
    data: [],
    fill: true,
    backgroundColor: 'rgba(192, 224, 224, 0.5)',
    pointStyle: false,
    tension: 0.1,
    yAxisID: 'bpmY',
    showLine: false
  },
  {
    type: 'line',
    label: '80% zone',
    data: [],
    fill: true,
    backgroundColor: 'rgba(255, 255, 192, 0.5)',
    pointStyle: false,
    tension: 0,
    yAxisID: 'bpmY',
    showLine: false
  },
  {
    type: 'line',
    label: '90% zone',
    data: [],
    fill: true,
    backgroundColor: 'rgba(255, 160, 160, 0.5)',
    pointStyle: false,
    tension: 0,
    yAxisID: 'bpmY',
    showLine: false
  }
#+end_src
To avoid littering the legends table, we will filter out the useless heart rate zone legends.
#+caption: Filter out heart rate zone legends
#+begin_src js :noweb-ref Filter out heart rate zone legends
  plugins: {
    legend: {
      labels: {
        filter: item => (item.text !== '50% zone'
                         && item.text !== '60% zone'
                         && item.text !== '70% zone'
                         && item.text !== '80% zone'
                         && item.text !== '90% zone')
      }
    },
    tooltip: {
      filter: item => (item.datasetIndex !== 4
                       && item.datasetIndex !== 5
                       && item.datasetIndex !== 6
                       && item.datasetIndex !== 7
                       && item.datasetIndex !== 8)
    }
  }
#+end_src

Speed is similar to heart rate, +but uses a different axis+ all use the same 0-200 axis for simplicity of a kind. 200 km/h or rpm seems like a sensible maximum for both speed and cadence to have them visually separate from heart rate and each other, but still be distinguishable even at around 5 km/h.
#+caption: Plot speed
#+begin_src js :noweb-ref Plot speed
  {
    type: 'line',
    label: 'Speed',
    data: [],
    fill: false,
    borderColor: 'rgb(255, 255, 64)',
    pointStyle: false,
    tension: 0.1,
    yAxisID: 'bpmY'
  }
#+end_src
The unused speed axis:
#+caption: Scale speed
#+begin_src js :noweb-ref Scale speed
  speedY: {
    min: 0,
    max: 200,
    position: 'right',
    title: {
      display: true,
      text: 'Km/h',
    }
  }
#+end_src

Cadence goes in with speed.
#+caption: Plot cadence
#+begin_src js :noweb-ref Plot cadence
  {
    type: 'line',
    label: 'Cadence',
    data: [],
    fill: false,
    borderColor: 'rgb(64, 160, 64)',
    pointStyle: false,
    tension: 0.1,
    yAxisID: 'bpmY'
  }
#+end_src

Finally, laps will be (for now) implemented with simple dots using a scatter type. We'll make the dots appear on top of the heart rate dataset, as it is found on all activities.
#+caption: Plot laps
#+begin_src js :noweb-ref Plot laps
  {
    type: 'scatter',
    label: 'Lap',
    data: [],
    fill: false,
    borderColor: 'rgb(128, 128, 128)',
    pointStyle: 'circle',
    radius: 10,
    tension: 0.1,
    yAxisID: 'bpmY',
    xAxisID: 'x'
  }
#+end_src

Everything above then is shown as a function of time. It's obvious from labels what it is, so no separate title is required.
#+caption: Scale time
#+begin_src js :noweb-ref Scale time
  x: {
    min: 0,
    title: {
      display: false,
      text: 'Time'
    },
    grid: {
      color: 'rgb(255,255,255)'
    }
  }
#+end_src

This will then show up on a canvas.
#+caption: Show plotted activity
#+begin_src html :noweb-ref Show plotted activity
  <div style="position: relative;"><canvas id="activityChart"></canvas></div>
#+end_src

We can then put it all together
#+caption: Lay out selected activity
#+begin_src html :noweb-ref Lay out selected activity
  <<Show plotted activity>>
  <<Plot selected activity>>
#+end_src

Frontend will receive the data in a JSON parseable format. The chart is filled & updated with data clientside due to some quirks regarding the single-page nature of the frontend. Fully serverside, the chart would have trouble updating when moving between activities, even if the data-fields in <script> would update.

IHP has a premade JS function that runs on every page load and as turbolinks change it:
#+caption: static/app.js
#+name: Run Javascript on page load
#+begin_src js :tangle liikuntakirja/static/app.js
  $(document).on('ready turbolinks:load', function () {
    <<Update chart>>
      // This is called on the first page load *and* also when the page is changed by turbolinks
  });
#+end_src

We'll then update the chart:
#+caption: Update chart
#+begin_src js :noweb-ref Update chart
  var plotter = document.getElementById('activityPlotter');
  aPChart.data.datasets[0].data = JSON.parse(plotter.dataset.heartrate);
  aPChart.data.datasets[1].data = JSON.parse(plotter.dataset.speed);
  aPChart.data.datasets[2].data = JSON.parse(plotter.dataset.cadence);
  aPChart.data.datasets[3].data = JSON.parse(plotter.dataset.laps);
  aPChart.data.datasets[4].data = JSON.parse(plotter.dataset.heartratezone1);
  aPChart.data.datasets[5].data = JSON.parse(plotter.dataset.heartratezone2);
  aPChart.data.datasets[6].data = JSON.parse(plotter.dataset.heartratezone3);
  aPChart.data.datasets[7].data = JSON.parse(plotter.dataset.heartratezone4);
  aPChart.data.datasets[8].data = JSON.parse(plotter.dataset.heartratezone5);
  aPChart.data.labels = JSON.parse(plotter.dataset.time);
  aPChart.scales.x.max = JSON.parse(plotter.dataset.totaltime);
  aPChart.update('none');
  aPChart.resize();
#+end_src

We should now have a graphical presentation of the data done.
#+begin_src sh :results file graphics :file "./visualizations/ui_visualization.png" :dir .
  <<Chromium binary>> <<Chromium options>> "http://localhost:8000"
  <<Post-process screenshot>> visualizations/ui_visualization.png
#+end_src

Next we'll transform the model data for the frontend.

**** Sculpting the data

We desperately need a type for the JSONified chart data
#+caption: Type ChartData
#+begin_src haskell :noweb-ref Type ChartData
  data ChartData = ChartData
    { cdHeartRate :: Text
    , cdHeartRateZones :: (Text, Text, Text, Text, Text)
    , cdSpeed :: Text
    , cdCadence :: Text
    , cdLaps :: Text
    , cdTime :: Text
    , cdTotalTime :: Text
    }
#+end_src

We can then start working on sculpting the data. We can assume that any sequential pair of Trackpoints  will have 1-second interval between them. Since Haskell lists will read as JSON and the coordinate JSON is easy to roll by hand, we can avoid using external JSON libraries. We'll start off with heart rate. All integers will turn into floats during sculpting. The resulting data will have each list item represent a 10 second period. =heartRate= is used in calculating lap indicators, so we'll =show= it when constructing =ChartData=.
#+caption: Sculpt Activity into ChartData
#+begin_src haskell :noweb-ref Sculpt Activity into ChartData
  chartActivityData :: HealthInformation -> (Maybe Activity, [Lap], [[Trackpoint]]) -> Maybe ChartData
  chartActivityData _          (Nothing, _, _) = Nothing
  chartActivityData healthInfo (Just activity, laps, tps) =
    let heartRate = avgOver10s (map (fromIntegral . fromMaybe 0 . hr) $ concat tps)
        <<Sculpt Activity into ChartData zones>>
        <<Sculpt Activity into ChartData speed and cadence>>
        <<Sculpt Activity into ChartData laps>>
        <<Sculpt Activity into ChartData time>>
    <<Sculpt Activity into ChartData end>>

  <<avgOver10s>>
#+end_src

Average over 10 seconds, but last average might average over only 1-9 seconds.
#+caption: avgOver10s
#+begin_src haskell :noweb-ref avgOver10s
  avgOver10s :: [Float] -> [Float]
  avgOver10s x =
    let average x = sum x / (fromIntegral $ length x)
    in if length x > 10
       then average (take 10 x) : avgOver10s (drop 10 x)
       else average x : []
#+end_src

Then we'll work on heart rate zones. They have a simple spread based on deciles and a general rule on maximum heart rate being 220 minus your age BPM. As the zones are drawn as overlapping blocks, we'll start the 90% zone at 100%, 80% at 90%, etc.
#+caption: Sculpt Activity into ChartData zones
#+begin_src haskell :noweb-ref Sculpt Activity into ChartData zones
      topHeartRate = fromIntegral $ 220 - age healthInfo
      heartRateZones = (show . replicate (length heartRate) . round $ topHeartRate * 0.6,
                        show . replicate (length heartRate) . round $ topHeartRate * 0.7,
                        show . replicate (length heartRate) . round $ topHeartRate * 0.8,
                        show . replicate (length heartRate) . round $ topHeartRate * 0.9,
                        show . replicate (length heartRate) . round $ topHeartRate * 1.0)
#+end_src

Speed requires some differential calculations. Cadence not so much.
#+caption: Sculpt Activity into ChartData speed and cadence
#+begin_src haskell :noweb-ref Sculpt Activity into ChartData speed and cadence
      speed = show . avgOver10s . deriveKmhSpeedFromDistance $ concat tps
      cadence = show . avgOver10s $ map (\tp -> fromIntegral $ fromMaybe 0 tp.cadence) . concat $ tps
#+end_src

#+caption: deriveKmhSpeedFromDistance
#+begin_src haskell :noweb-ref deriveKmhSpeedFromDistance
  deriveKmhSpeedFromDistance :: [Trackpoint] -> [Float]
  deriveKmhSpeedFromDistance (tp:[]) = []
  deriveKmhSpeedFromDistance (tp1:tp2:tps) =
    case pointDistance tp1 of
      Just dist1 ->
        ((fromJust (pointDistance tp2) - dist1) * 3.6) : deriveKmhSpeedFromDistance (tp2:tps)
      Nothing ->
        0.0 : deriveKmhSpeedFromDistance (tp2:tps)

#+end_src

Now, laps, time, and total time will require dealing with =Data.Time=. We will have to calculate =NominalDiffTimes= from =UTCTimes= and put them on the chart.
#+caption: Import Data.Time for sculpting ChartData
#+begin_src haskell :noweb-ref Import Data.Time for sculpting ChartData
  import Data.Time.Clock (diffUTCTime, nominalDiffTimeToSeconds)
#+end_src

With laps we need label for X axis and heart rate as of new lap for Y. X coordinate is the difference between activity and lap starts in seconds divided by 5 & nicely formatted. We get the label from =time= we're handling next. Y coordinate is current heart rate at that time. We don't need to know when the first lap started. We also need a more complex JSON than what the Show typeclass produces.
#+caption: Sculpt Activity into ChartData laps
#+begin_src haskell :noweb-ref Sculpt Activity into ChartData laps
  lapXCoordinate lap = floor (diffUTCTime (lap.startTime) (activity.startTime)) `div` 10 :: Int
  newLaps = (\str -> T.concat["[", str, "]"]) . intercalate "," . map pack . drop 1 $
            map (\lap -> "{\"x\":\"" ++ unpack (time !! (lapXCoordinate lap)) ++
                         "\", \"y\":" ++ unpack (show (heartRate !! (lapXCoordinate lap))) ++ "}") laps
#+end_src

Time is then time.. averaged over 10 seconds (4.5, 14.5, .. as first trackpoint is at 0 seconds) But we'll cheat a bit and =floor= + remove 4 seconds from, so the chart starts at 00.00 with some nice formatting. =time= is used for =totalTime=, so it's =show='d in the constructor.
#+caption: Sculpt Activity into ChartData time
#+begin_src haskell :noweb-ref Sculpt Activity into ChartData time
  zeroPad t = pack (replicate (2 - length (unpack t)) '0' ++ (unpack t))
  time = map (\t -> zeroPad (show (t `div` 60)) ++ ":"
                       ++ zeroPad (show (t `mod` 60))) $ map (\t -> floor t - 4) $ avgOver10s [0.0..(fromIntegral (length (concat tps) - 1))]
  --time = map (\t -> floor t - 2) $ avgOver5s [0.0..(fromIntegral (length (concat tps) - 1))]
#+end_src

Total time is just the length of the X axis in this case.
#+caption: Sculpt Activity into ChartData end
#+begin_src haskell :noweb-ref Sculpt Activity into ChartData end
      totalTime = show . length $ time
  in Just $ ChartData (show heartRate) heartRateZones speed cadence newLaps (show time) totalTime
  where
    <<deriveKmhSpeedFromDistance>>
#+end_src

The data for sculpting is then fetched from the database.
#+caption: Query Activity and its children
#+begin_src haskell :noweb-ref Query Activity and its children
  queryActivityAndItsChildren :: (?modelContext :: ModelContext) => Maybe Activity -> IO (Maybe Activity, [Lap], [[Trackpoint]])
  queryActivityAndItsChildren maybeActivity = do
    case maybeActivity of
      Nothing ->
        return (Nothing, [], [[]])
      Just activity -> do
        laps <- query @Lap
                |> filterWhere (#activityId, unpackId activity.id)
                |> orderBy #startTime
                |> fetch
        tps <- mapM (\lap -> query @Trackpoint
                             |> filterWhere (#lapId, unpackId lap.id)
                             |> orderBy #pointTime
                             |> fetch
                    ) laps
        return (Just activity, laps, tps)
#+end_src

Everything in the backend is pulled together in =ShowActivityAction=
#+caption: Show an activity
#+begin_src haskell :noweb-ref Show an activity
  action ShowActivityAction { activityId } = do
    (selectedActivity, laps, tps) <- activityId |> fetchOneOrNothing >>= queryActivityAndItsChildren
    case selectedActivity of
      Nothing -> do
        setErrorMessage "Activity not found"
        redirectTo ActivitiesAction
      Just _ -> do
        activities <- query @Activity |> orderByDesc #startTime |> fetch
        healthInfo <- query @HealthInformation |> fetchOne
        let newActivity = newRecord
            chartData = chartActivityData healthInfo (selectedActivity, laps, tps)
        render IndexView { .. }
#+end_src

All propositions should now pass.
#+begin_src haskell
  :l Test/Controller/ActivitiesSpec.hs
  hspec $ aroundAll (withIHPApp WebApplication config) $ testChartData
#+end_src


** User deletes an activity
User has clicked delete button and confirmed deletion. Activity and its constituents will be removed from the database.
#+caption: Delete an activity
#+begin_src haskell :noweb-ref Delete an activity
  action DeleteActivityAction { activityId } = do
      (maybeActivity, laps, tps) <- activityId |> fetchOneOrNothing >>= queryActivityAndItsChildren
      case maybeActivity of
        Nothing -> do
          setErrorMessage "Activity not found"
          redirectTo ActivitiesAction
        Just activity -> do
          deleteRecord activity
          deleteRecords laps
          deleteRecords (concat tps)
          setSuccessMessage "Activity deleted"
          redirectTo ActivitiesAction
#+end_src

* Boilerplate epilogue
#+PROPERTY:header-args :dir ./liikuntakirja :mkdirp yes :exports code :noweb no-export :eval never-export

#+caption: Web/Types.hs
#+begin_src haskell :tangle liikuntakirja/Web/Types.hs
  module Web.Types where

  import IHP.Prelude
  import IHP.ModelSupport
  import Generated.Types

  data WebApplication = WebApplication deriving (Eq, Show)

  <<Tcx types>>

  <<Type ActivitiesController>>

  <<Type HealthInformationController>>

  <<Type ChartData>>
#+end_src

#+caption: Application/Helper/Controller.hs
#+begin_src haskell :tangle liikuntakirja/Application/Helper/Controller.hs
  module Application.Helper.Controller where

  import IHP.ControllerPrelude

  -- Here you can add functions which are available in all your controllers
#+end_src

#+caption: Web/Routes.hs
#+begin_src haskell :tangle liikuntakirja/Web/Routes.hs
  module Web.Routes where
  import IHP.RouterPrelude
  import Generated.Types
  import Web.Types

  -- Generator Marker
  <<Controller routing instances>>
#+end_src

#+caption: Web/FrontController.hs
#+begin_src haskell :tangle liikuntakirja/Web/FrontController.hs
  module Web.FrontController where

  import IHP.RouterPrelude
  import Web.Controller.Prelude
  import Web.View.Layout (defaultLayout)

  -- Controller Imports
  <<Import controller actions>>

  instance FrontController WebApplication where
      controllers =
          [ <<Set ActivitiesAction as front page>>
          -- Generator Marker
          <<Parse controller routes>>
          ]

  instance InitControllerContext WebApplication where
      initContext = do
          setLayout defaultLayout
          initAutoRefresh
#+end_src

An SQL schema file is used to set up the database. Any further manipulation should be in the fixtures file below the schema, although fixtures don't get loaded in unit tests for some reason.
#+caption: Application/Schema.sql
#+begin_src sql :tangle liikuntakirja/Application/Schema.sql
  -- Your database schema. Use the Schema Designer at http://localhost:8001/ to add some tables.
  <<Tcx schema>>
  <<HealthInformation schema>>
#+end_src
#+caption: Application/Fixtures.sql
#+begin_src sql :tangle liikuntakirja/Application/Fixtures.sql
  <<Insert default HealthInformation row>>
#+end_src
